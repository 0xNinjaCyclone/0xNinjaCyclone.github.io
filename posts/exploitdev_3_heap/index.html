<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 3- Understanding Heap Memory | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 3- Understanding Heap Memory</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2023-12-17</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 1603 words</span>
  <span> • 8 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/heap">heap</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p>Hello everyone, hope you&rsquo;re all well. In this article, we&rsquo;re going to talk about heap memory. We&rsquo;ll look at what it is, how it works, and why software uses it. I&rsquo;ll explain the heap&rsquo;s special functions (APIs) and what happens in the background when software uses these functions. Let&rsquo;s get started and learn more about heap memory!</p>
<h2 id="what-is-heap">What is Heap?</h2>
<p>The heap is a contiguous large region of memory that is subdivided into chunks to be dynamically allocated and deallocated at run time as needed. Each chunk in the heap contains not only the data for which memory has been allocated, but also includes additional metadata that guides the operating system in handling it.</p>
<h2 id="heaps-apis">Heap&rsquo;s APIs</h2>
<p>When dealing with heap memory, developers use specific functions provided by libraries like <strong>libc</strong> and <strong>MSVC</strong>. These functions, or APIs, are tailored to interact seamlessly with the underlying operating system, ensuring optimal memory management. Each operating system has its own implementation details, hence the need for different APIs.</p>
<h3 id="malloc">malloc</h3>
<p>This function allows the developers to ask the OS for some memory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>( nSize );
</span></span></code></pre></div><p>This function orders the OS to find an unused memory, and when the OS finds it will return an initialized memory address, if the OS fails, <code>NULL</code> will be returned and this is called <strong>Out Of Memory</strong> case. In reality, <code>malloc</code> will call more low-level APIs to do this task, such as <code>HeapAlloc</code>, <code>LocalAlloc</code> on Windows or <code>sbrk</code>, <code>mmap</code> on Linux.</p>
<h3 id="calloc">calloc</h3>
<p>This function is exactly like <code>malloc</code> but it zeroes the allocated memory and allows developers to specify the number of items to be allocated as an array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nNumberOfItems <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>( nNumberOfItems, nSize );
</span></span></code></pre></div><h3 id="realloc">realloc</h3>
<p>This function allows developers to re-allocate memory under their control if the current memory they have is insufficient.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> nNewSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">4096</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">realloc</span>( ptr, nNewSize );
</span></span></code></pre></div><p>The OS will expand that <code>chunk</code> if there is unused space next to it, and if not, the OS will look for other unused memory sufficient for the new size, and the OS will automatically move the data from the old memory to the new, Then releases the old to be available for another request. Or <code>NULL</code> will be returned if there is no more space. And that’s why we are reassigning <code>ptr</code>, because the function may return a different address in the case we discussed. This function calls more low-level APIs such as <code>HeapReAlloc</code>, <code>LocalReAlloc</code> on Windows, or <code>mremap</code> on Linux.</p>
<h3 id="free">free</h3>
<p>This function releases back the memory that has been allocated via any API that we have explained above.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a6e22e">free</span>( ptr );
</span></span></code></pre></div><p>Any memory allocation must have a corresponding deallocation. This function calls either <code>HeapFree</code>, <code>LocalFree</code> on Windows, or <code>munmap</code> on Linux. Deallocating the chunk does not mean clearing its payload, Only telling the OS to mark the chunk as unused, to be available for other requests. The payload does not necessary to be deleted, because the next owner will overwrite it.</p>
<h3 id="other-methods">other methods</h3>
<p><strong>C++</strong> provides developers with keywords such as <code>new</code>, <code>delete</code>, to dynamically allocate memory, and they follow the same approach we have explained.</p>
<h2 id="allocation-process">Allocation process</h2>
<p>In the allocation process, speed is key. Windows and Linux approach this with different data structures: Windows uses <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/bstree.c">Trees data structures</a>, which are efficient in sorting and quickly locating free memory chunks.Linux, on the other hand, opts for <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/llist.c">singly</a>/<a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/dllist.c">doubly</a> linked lists, offering simplicity and flexibility. These choices reflect different prioritizations in memory management strategies between the two operating systems.</p>
<h2 id="deallocation-process">Deallocation process</h2>
<p>In general, freeing memory does not actually return it to the operating system for other applications to use. Deallocating a chunk means marking this chunk of memory as &lsquo;free to be reused&rsquo; by the application, but it still belongs to the application, OS will never give it to other applications. However, if the top chunk in a heap becomes large enough, some of that memory may be returned to the operating system. Also, freed chunks will be tracked by the OS, to help the OS respond quickly for the new allocation requests.</p>
<h2 id="what-is-a-chunk">What is a Chunk?</h2>
<p>A chunk is a piece of the heap, it contains not only the payload but also other metadata that helps the OS to easily manage and maintain the memory, and its structure is differs when it is in use and when it is not.</p>
<h3 id="in-use-chunk-windows">In-use Chunk (Windows)</h3>
<center><img src="/imgs/heap_win_inuse.jpg" width="512"/></center>
<ul>
<li>(<strong>Sizes</strong>) - Encoded substructure that encapsulates important size and state
information
<ul>
<li>(<strong>MemoryCost</strong>) - Used in free VS blocks. Indicates the number of pages occupied by the current chunk apart from the page where the chunk&rsquo;s vs header lies.</li>
<li>(<strong>UnsafeSize</strong>) - The size of the chunk divided by 16, This value will be used during the FreeChunkTree allocation to compare different nodes and find a suitable chunk according to the requested size.</li>
<li>(<strong>UnsafePrevSize</strong>) - The size of the previous chunk divided by 16.</li>
<li>(<strong>Allocated</strong>) - Indicates whether the chunk is allocated/used or not.</li>
<li>(<strong>KeyUShort</strong>) - Used in free chunks.</li>
<li>(<strong>KeyULong</strong>) - Used in free chunks.</li>
</ul>
</li>
<li>(<strong>EncodedSegmentPageOffset</strong>) - Encoded offset of the chunk from the start of the VS subsegment.
in pages.</li>
<li>(<strong>UnusedBytes</strong>) - Indicates whether the chunk has unused bytes.</li>
</ul>
<h3 id="in-use-chunk-linux">In-use Chunk (Linux)</h3>
<center><img src="/imgs/heap_linux_inuse.png" width="512"/></center>
<ul>
<li>(<strong>A</strong>) Allocated Arena - the main arena uses the application&rsquo;s heap. Other arenas use mmap&rsquo;d heaps. If this bit is 0, the chunk comes from the main arena and the main heap. If this bit is 1, the chunk comes from mmap&rsquo;d memory and the location of the heap can be computed from the chunk&rsquo;s address.</li>
<li>(<strong>M</strong>) MMap&rsquo;d chunk - indicates that this chunk was allocated with a single call to <code>mmap</code> and is not part of a heap at all.</li>
<li>(<strong>P</strong>) Previous chunk is in use? - indicates whether the previous chunk is still being used by the application, or not, if set thus the <code>prev_size</code> field is invalid.</li>
</ul>
<h3 id="free-chunk-windows">Free Chunk (Windows)</h3>
<center><img src="/imgs/heap_win_free.jpg" width="512"/></center>
<p>As you see the first part is the same, but the last part looks a bit different, <code>Node.Left</code> and <code>Node.Right</code> and <code>Node.Parent</code> have been added which are pointers that will be used to access the appropriate chunk in <strong>FreeChunkTree</strong>. depending on its size field.</p>
<ul>
<li>(<strong>Node.Left</strong>) - A pointer to the left chunk.</li>
<li>(<strong>Node.Right</strong>) - A pointer to the right chunk.</li>
<li>(<strong>Node.Parent</strong>) - A pointer to the root chunk in their subtree.</li>
</ul>
<h3 id="free-chunk-linux">Free Chunk (Linux)</h3>
<center><img src="/imgs/heap_linux_free.png" width="512"/></center>
<p>As you see the first part is the same, but the last part looks a bit different, <code>fwd</code> and <code>bck</code> have been added which are pointers that will be used to access the appropriate <strong>bin</strong>. As well as <code>fd_nextsize</code> and <code>bk_nextsize</code> will be added for large chunks only which are pointers that may be <code>NULL</code>, and may point to its own chunk forming a loop of one, in addition to larger loops. Also the size of the chunk will be set at the end.</p>
<h2 id="what-is-freechunktree-windows">What is FreeChunkTree? (Windows)</h2>
<p>Windows OS tracks the freed chunks using <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/bstree.c">Trees data structures</a> as we said before. <strong>FreeChunkTree</strong> is the main structure that is used to store free chunks during deallocation so that the allocator can quickly find the suitable chunk.</p>
<h2 id="what-is-lookaside-windows">What is Lookaside? (Windows)</h2>
<p>Lookaside are <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/llist.c">singly-linked lists</a> of free chunks in each size. It&rsquo;s used to track small chunks. The idea behind the lookaside list is to enable speed and rapid lookup time. It allows no more than 3 free chunks per list entry. If a new chunk gets deallocated, and there are already 3 entries for that particular chunk size, then it is freed to the <strong>FreeChunkTree</strong>.</p>
<h2 id="what-are-bins-linux">What are Bins? (Linux)</h2>
<p>The allocation process should be done very fast, As we know the chunks are either in use by the application or they’re not, the chunks in use are not tracked, but the free chunks are tracked via storing them in various lists based on size and other information so that the allocators such as <code>malloc</code> can quickly find the suitable chunks. Those tracking lists are called <strong>bins</strong>. There are various kinds of bins.</p>
<h3 id="fast-bins">Fast bins</h3>
<p>The fast bins contain small chunks which are stored in size-specific bins. The chunks in the fastbins may be moved to other bins as needed, and they are stored in an array of <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/llist.c">singly-linked lists</a>, since they&rsquo;re all the same size and chunks in the middle of the list need never be accessed.</p>
<h3 id="unsorted-bin">Unsorted bin</h3>
<p>There is only one of these. When small and large chunks are deallocated, they end up in this bin to make allocations and deallocations faster. They&rsquo;re sorted later, in malloc, in order to give them one chance to be quickly re-used.</p>
<h3 id="small-bins">Small bins</h3>
<p>The small bins are like fast bins, each bin contains chunks of the same size. But the small bins are <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/dllist.c">doubly-linked</a> and when allocation or deallocation is required, the first chunk pushed onto the list is the first to be popped off, as well as can be popped off from the middle. Additionally, the <code>fwd</code> and <code>bck</code> pointers as we saw before are to point to the next and previous chunks in the bin.</p>
<h3 id="large-bins">Large bins</h3>
<p>The large bins are unlike the previous bins that we have talked about, each large bin can contain more than one size.
The chunks are ordered in decreasing order of size, Which means inserting or deleting a chunk can occur at any point in the list.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In conclusion, understanding heap memory is vital for effective exploit development and software design. As we&rsquo;ve seen, its dynamic nature offers both challenges and opportunities. I encourage you to deepen your understanding of data structures, as this knowledge is key to mastering heap memory management. Thank you for joining me on this exploration.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
