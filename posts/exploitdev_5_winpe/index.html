<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 5- Dealing with Windows PE files programmatically | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 5- Dealing with Windows PE files programmatically</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2023-12-31</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 5744 words</span>
  <span> • 27 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/binary-file">binary-file</a>, 
        <a href="/tags/pe">pe</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p>Welcome to our in-depth exploration of Windows PE files. Understanding the PE format is crucial for cybersecurity professionals, as it provides insight into the architecture and functioning of Windows executables. In this article, we delve into parsing PE files programmatically, a skill essential for analyzing and exploiting software vulnerabilities. Although we won&rsquo;t examine every detail of the PE format, we&rsquo;ll focus on the most pertinent aspects that are essential for cybersecurity experts. For foundational knowledge, I recommend reading <a href="https://0xninjacyclone.github.io/posts/exploitdev_4_binfiles/">the previous part</a>, which offers a theoretical overview of PE files, their structure, and key concepts related to this topic. Let&rsquo;s embark on this technical journey to enhance our understanding and skills in handling Windows PE files.</p>
<h2 id="important-conceptsnotes">Important Concepts/Notes</h2>
<p>Before we get into the article, we have to understand important concepts that we’re going to see a lot.</p>
<ul>
<li>
<p><strong>RVA (Relative Virtual Address)</strong>. an <strong>RVA</strong> is the address of an item after it is loaded into memory, with the base address of the image file subtracted from it. Because we will parse the PE from the hard drive, most of the time we will have RVAs that need to be converted to file offset. I&rsquo;ve developed this function for this purpose:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>DWORD <span style="color:#a6e22e">ResolveOffset</span>(LPVOID lpBaseAddress, DWORD dwRVA)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD dwNumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Nt Headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Retrieve number of sections from the file header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwNumberOfSections <span style="color:#f92672">=</span> ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the section header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader <span style="color:#f92672">+</span> ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.SizeOfOptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all sections header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( dwNumberOfSections<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check if the given RVA in the range of this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>			dwRVA <span style="color:#f92672">&gt;=</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex;"><span>			dwRVA <span style="color:#f92672">&lt;</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">+</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfRawData
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Calculate the file offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> dwRVA <span style="color:#f92672">-</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">+</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>PointerToRawData;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next section header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_SECTION_HEADER);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Invalid RVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Don&rsquo;t worry, I will explain these complicated things and you will understand, what I want you to know now is how to calculate the file offset from an RVA, the algorithm works as follows:</p>
<ol>
<li>Iterate over all sections to determine which section the RVA lives in.</li>
<li>Calculate file offset using this equation <code>RVA - SectionVirtualAddress + SectionRawOffset</code>.</li>
</ol>
</li>
<li>
<p><strong>DWORD_PTR</strong>: A 32/64-bit numerical data type, we will use this type to do pointer calculations easily.</p>
</li>
<li>
<p>Any type starting with <strong>P</strong> is a pointer. For example, <code>PIMAGE_DOS_HEADER pDos;</code> is a pointer equivalent to <code>IMAGE_DOS_HEADER *pDos;</code>.</p>
</li>
</ul>
<h2 id="prepare-pe-parser">Prepare PE parser</h2>
<p>Let&rsquo;s start writing our PE parser. First, we implement the main function that takes the PE file name via command line arguments.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LPVOID lpBuffer;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> nRet <span style="color:#f92672">=</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( argc <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Usage:</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">./PEParser &lt;/path/to/pefile&gt;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	lpBuffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">ReadPEFile</span>(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>lpBuffer )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed to read %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		PARSE HERE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nRet <span style="color:#f92672">=</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LEAVE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( lpBuffer ) <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpBuffer);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> nRet;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The main function reads the PE file by using the <code>ReadPEFile</code> function, which is implemented as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>LPVOID <span style="color:#a6e22e">ReadPEFile</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpFileName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HANDLE hFile <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	LPVOID lpBuffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	DWORD dwSize, dwRead;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get a handle on the file with some attributes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hFile <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>( cpFileName, GENERIC_READ, <span style="color:#ae81ff">0</span>, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If the given PE file doesn&#39;t exist, return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( hFile <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	dwSize <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetFileSize</span>(hFile, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If the given PE file was empty or invalid, close the file handle, return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( dwSize <span style="color:#f92672">==</span> INVALID_FILE_SIZE <span style="color:#f92672">||</span> dwSize <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Allocate sufficient memory for the PE in the main heap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	lpBuffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">HeapAlloc</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, dwSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If allocation request failed, return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> lpBuffer )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Read the PE file in the allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">ReadFile</span>(hFile, lpBuffer, dwSize, <span style="color:#f92672">&amp;</span>dwRead, NULL) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If we failed to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// Deallocate the memory, close the file handle, and return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpBuffer);
</span></span><span style="display:flex;"><span>		lpBuffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LEAVE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( hFile ) <span style="color:#a6e22e">CloseHandle</span>(hFile);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> lpBuffer;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="pe-headers">PE Headers</h2>
<p>Windows PE headers contain a lot of valuable information, let&rsquo;s take a look at them.</p>
<h3 id="dos-header">DOS Header</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_DOS_HEADER
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     WORD e_magic;
</span></span><span style="display:flex;"><span>     WORD e_cblp;
</span></span><span style="display:flex;"><span>     WORD e_cp;
</span></span><span style="display:flex;"><span>     WORD e_crlc;
</span></span><span style="display:flex;"><span>     WORD e_cparhdr;
</span></span><span style="display:flex;"><span>     WORD e_minalloc;
</span></span><span style="display:flex;"><span>     WORD e_maxalloc;
</span></span><span style="display:flex;"><span>     WORD e_ss;
</span></span><span style="display:flex;"><span>     WORD e_sp;
</span></span><span style="display:flex;"><span>     WORD e_csum;
</span></span><span style="display:flex;"><span>     WORD e_ip;
</span></span><span style="display:flex;"><span>     WORD e_cs;
</span></span><span style="display:flex;"><span>     WORD e_lfarlc;
</span></span><span style="display:flex;"><span>     WORD e_ovno;
</span></span><span style="display:flex;"><span>     WORD e_res[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>     WORD e_oemid;
</span></span><span style="display:flex;"><span>     WORD e_oeminfo;
</span></span><span style="display:flex;"><span>     WORD e_res2[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>     LONG e_lfanew;
</span></span><span style="display:flex;"><span>} IMAGE_DOS_HEADER, <span style="color:#f92672">*</span>PIMAGE_DOS_HEADER;
</span></span></code></pre></div><ul>
<li><strong>e_magic</strong>: The image magic number (MZ)</li>
<li><strong>e_lfanew</strong>: An RVA of <code>IMAGE_NT_HEADERS</code>, this member very important for the loader which tells the loader where to look for the file header.</li>
</ul>
<h3 id="nt-headers">NT Headers</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_NT_HEADERS {
</span></span><span style="display:flex;"><span>  DWORD                   Signature;
</span></span><span style="display:flex;"><span>  IMAGE_FILE_HEADER       FileHeader;
</span></span><span style="display:flex;"><span>  IMAGE_OPTIONAL_HEADER32 OptionalHeader;
</span></span><span style="display:flex;"><span>} IMAGE_NT_HEADERS32, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS32;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_NT_HEADERS64 {
</span></span><span style="display:flex;"><span>  DWORD                   Signature;
</span></span><span style="display:flex;"><span>  IMAGE_FILE_HEADER       FileHeader;
</span></span><span style="display:flex;"><span>  IMAGE_OPTIONAL_HEADER64 OptionalHeader;
</span></span><span style="display:flex;"><span>} IMAGE_NT_HEADERS64, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS64;
</span></span></code></pre></div><ul>
<li>
<p><strong>Signature</strong>: A signature identifying the file as a PE image (PE\0\0)</p>
</li>
<li>
<p><strong>FileHeader</strong>: Contains valuable information about the PE file, this also called <strong>The COFF File Header</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_FILE_HEADER {
</span></span><span style="display:flex;"><span>  WORD  Machine;
</span></span><span style="display:flex;"><span>  WORD  NumberOfSections;
</span></span><span style="display:flex;"><span>  DWORD TimeDateStamp;
</span></span><span style="display:flex;"><span>  DWORD PointerToSymbolTable;
</span></span><span style="display:flex;"><span>  DWORD NumberOfSymbols;
</span></span><span style="display:flex;"><span>  WORD  SizeOfOptionalHeader;
</span></span><span style="display:flex;"><span>  WORD  Characteristics;
</span></span><span style="display:flex;"><span>} IMAGE_FILE_HEADER, <span style="color:#f92672">*</span>PIMAGE_FILE_HEADER;
</span></span></code></pre></div><ul>
<li><strong>Machine</strong>: Indicates the type of machine (CPU Architecture) the executable is running on. This value can be (IMAGE_FILE_MACHINE_I386 for x86, IMAGE_FILE_MACHINE_IA64 for Intel Itanium, IMAGE_FILE_MACHINE_AMD64 for x64)</li>
<li><strong>NumberOfSections</strong>: The number of sections. This indicates the size of the section table, which immediately follows the headers.</li>
<li><strong>TimeDateStamp</strong>: This represents the date and time the image was created by the linker.</li>
<li><strong>SizeOfOptionalHeader</strong>: The size of the optional header, in bytes.</li>
</ul>
</li>
<li>
<p><strong>OptionalHeader</strong>: Contains valuable information about the PE file like <strong>FileHeader</strong> with more details.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_OPTIONAL_HEADER {
</span></span><span style="display:flex;"><span>  WORD                 Magic;
</span></span><span style="display:flex;"><span>  BYTE                 MajorLinkerVersion;
</span></span><span style="display:flex;"><span>  BYTE                 MinorLinkerVersion;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfCode;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfInitializedData;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfUninitializedData;
</span></span><span style="display:flex;"><span>  DWORD                AddressOfEntryPoint;
</span></span><span style="display:flex;"><span>  DWORD                BaseOfCode;
</span></span><span style="display:flex;"><span>  DWORD                BaseOfData;
</span></span><span style="display:flex;"><span>  DWORD                ImageBase;
</span></span><span style="display:flex;"><span>  DWORD                SectionAlignment;
</span></span><span style="display:flex;"><span>  DWORD                FileAlignment;
</span></span><span style="display:flex;"><span>  WORD                 MajorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MajorImageVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorImageVersion;
</span></span><span style="display:flex;"><span>  WORD                 MajorSubsystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorSubsystemVersion;
</span></span><span style="display:flex;"><span>  DWORD                Win32VersionValue;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfImage;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeaders;
</span></span><span style="display:flex;"><span>  DWORD                CheckSum;
</span></span><span style="display:flex;"><span>  WORD                 Subsystem;
</span></span><span style="display:flex;"><span>  WORD                 DllCharacteristics;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfStackReserve;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfStackCommit;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeapReserve;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeapCommit;
</span></span><span style="display:flex;"><span>  DWORD                LoaderFlags;
</span></span><span style="display:flex;"><span>  DWORD                NumberOfRvaAndSizes;
</span></span><span style="display:flex;"><span>  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
</span></span><span style="display:flex;"><span>} IMAGE_OPTIONAL_HEADER32, <span style="color:#f92672">*</span>PIMAGE_OPTIONAL_HEADER32;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_OPTIONAL_HEADER64 {
</span></span><span style="display:flex;"><span>  WORD                 Magic;
</span></span><span style="display:flex;"><span>  BYTE                 MajorLinkerVersion;
</span></span><span style="display:flex;"><span>  BYTE                 MinorLinkerVersion;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfCode;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfInitializedData;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfUninitializedData;
</span></span><span style="display:flex;"><span>  DWORD                AddressOfEntryPoint;
</span></span><span style="display:flex;"><span>  DWORD                BaseOfCode;
</span></span><span style="display:flex;"><span>  ULONGLONG            ImageBase;
</span></span><span style="display:flex;"><span>  DWORD                SectionAlignment;
</span></span><span style="display:flex;"><span>  DWORD                FileAlignment;
</span></span><span style="display:flex;"><span>  WORD                 MajorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MajorImageVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorImageVersion;
</span></span><span style="display:flex;"><span>  WORD                 MajorSubsystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorSubsystemVersion;
</span></span><span style="display:flex;"><span>  DWORD                Win32VersionValue;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfImage;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeaders;
</span></span><span style="display:flex;"><span>  DWORD                CheckSum;
</span></span><span style="display:flex;"><span>  WORD                 Subsystem;
</span></span><span style="display:flex;"><span>  WORD                 DllCharacteristics;
</span></span><span style="display:flex;"><span>  ULONGLONG            SizeOfStackReserve;
</span></span><span style="display:flex;"><span>  ULONGLONG            SizeOfStackCommit;
</span></span><span style="display:flex;"><span>  ULONGLONG            SizeOfHeapReserve;
</span></span><span style="display:flex;"><span>  ULONGLONG            SizeOfHeapCommit;
</span></span><span style="display:flex;"><span>  DWORD                LoaderFlags;
</span></span><span style="display:flex;"><span>  DWORD                NumberOfRvaAndSizes;
</span></span><span style="display:flex;"><span>  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
</span></span><span style="display:flex;"><span>} IMAGE_OPTIONAL_HEADER64, <span style="color:#f92672">*</span>PIMAGE_OPTIONAL_HEADER64;
</span></span></code></pre></div><ul>
<li>
<p><strong>Magic</strong>: The state of the image file.</p>
</li>
<li>
<p><strong>SizeOfCode</strong>: The size of the code section (<code>.text</code>), in bytes, or the sum of all such sections if there are multiple code sections.</p>
</li>
<li>
<p><strong>SizeOfInitializedData</strong>: The size of the initialized data section (<code>.data</code>), in bytes, or the sum of all such sections if there are multiple initialized data sections.</p>
</li>
<li>
<p><strong>SizeOfUninitializedData</strong>: The size of the uninitialized data section, in bytes (<code>.bss</code>), or the sum of all such sections if there are multiple uninitialized data sections.</p>
</li>
<li>
<p><strong>AddressOfEntryPoint</strong>: An RVA of the entry point function, For executable files, this is the starting address. For device drivers, this is the address of the initialization function. The entry point function is optional for DLLs. When no entry point is present, this member is zero.</p>
</li>
<li>
<p><strong>BaseOfCode</strong>: An RVA of the beginning of the code section (<code>.text</code>).</p>
</li>
<li>
<p><strong>ImageBase</strong>: The preferred address of the first byte of the image when it is loaded in memory. This value is a multiple of 64K bytes.</p>
</li>
<li>
<p><strong>SizeOfImage</strong>: The size of the image, in bytes, including all headers.</p>
</li>
<li>
<p><strong>SizeOfHeaders</strong>: The size of the headers including <code>IMAGE_DOS_HEADER</code>, <code>IMAGE_FILE_HEADER</code>, the size of optional header, and the size of all section headers.</p>
</li>
<li>
<p><strong>DataDirectory</strong>: An array of <code>IMAGE_DATA_DIRECTORY</code> structure, it can have up to 16 <code>IMAGE_DATA_DIRECTORY</code> entry.
This is a list of DataDirectory as defined in <code>Winin.h</code> (Each value represents an index in the DataDirectory array):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// Directory Entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   </span><span style="color:#75715e">// Export Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   </span><span style="color:#75715e">// Import Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   </span><span style="color:#75715e">// Resource Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   </span><span style="color:#75715e">// Exception Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   </span><span style="color:#75715e">// Security Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   </span><span style="color:#75715e">// Base Relocation Table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   </span><span style="color:#75715e">// Debug Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   </span><span style="color:#75715e">// Architecture Specific Data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   </span><span style="color:#75715e">// RVA of GP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_TLS             9   </span><span style="color:#75715e">// TLS Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   </span><span style="color:#75715e">// Load Configuration Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   </span><span style="color:#75715e">// Bound Import Directory in headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_IAT            12   </span><span style="color:#75715e">// Import Address Table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   </span><span style="color:#75715e">// Delay Load Import Descriptors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   </span><span style="color:#75715e">// COM Runtime descriptor
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_DATA_DIRECTORY {
</span></span><span style="display:flex;"><span>  DWORD VirtualAddress;
</span></span><span style="display:flex;"><span>  DWORD Size;
</span></span><span style="display:flex;"><span>} IMAGE_DATA_DIRECTORY, <span style="color:#f92672">*</span>PIMAGE_DATA_DIRECTORY;
</span></span></code></pre></div><ul>
<li><strong>VirtualAddress</strong>: The RVA of the section.</li>
<li><strong>Size</strong>: The size of the section, in bytes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="section-headers">Section headers</h3>
<p>Before the sections come there is a lot of information that guides how to deal with the sections. the section headers consist of an array of the following structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_SECTION_HEADER {
</span></span><span style="display:flex;"><span>  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>    DWORD PhysicalAddress;
</span></span><span style="display:flex;"><span>    DWORD VirtualSize;
</span></span><span style="display:flex;"><span>  } Misc;
</span></span><span style="display:flex;"><span>  DWORD VirtualAddress;
</span></span><span style="display:flex;"><span>  DWORD SizeOfRawData;
</span></span><span style="display:flex;"><span>  DWORD PointerToRawData;
</span></span><span style="display:flex;"><span>  DWORD PointerToRelocations;
</span></span><span style="display:flex;"><span>  DWORD PointerToLinenumbers;
</span></span><span style="display:flex;"><span>  WORD  NumberOfRelocations;
</span></span><span style="display:flex;"><span>  WORD  NumberOfLinenumbers;
</span></span><span style="display:flex;"><span>  DWORD Characteristics;
</span></span><span style="display:flex;"><span>} IMAGE_SECTION_HEADER, <span style="color:#f92672">*</span>PIMAGE_SECTION_HEADER;
</span></span></code></pre></div><ul>
<li><strong>Name</strong>: The name of the section.</li>
<li><strong>PhysicalAddress|VirtualSize</strong>: The total size of the section when loaded into memory, in bytes. If this value is greater than the SizeOfRawData member, the section is filled with zeroes.</li>
<li><strong>VirtualAddress</strong>: An RVA of the first byte of the section when loaded into memory.</li>
<li><strong>SizeOfRawData</strong>: The size of the initialized data on disk, in bytes. This value must be a multiple of the FileAlignment member of the <code>IMAGE_OPTIONAL_HEADER</code> structure.</li>
<li><strong>PointerToRawData</strong>: A pointer to the first page of the section within the file. This value must be a multiple of the FileAlignment member of the <code>IMAGE_OPTIONAL_HEADER</code> structure.</li>
<li><strong>PointerToRelocations</strong>: A pointer to the beginning of the relocation entries for the section. If there are no relocations, this value is zero.</li>
<li><strong>Characteristics</strong>: Flags that describe some information about the section like, is readable?, writable?, executable?, can be cached?, can be shared?, contains initialized or uninitialized data, and a lot more.</li>
</ul>
<h3 id="parse-headers">Parse headers</h3>
<p>Let&rsquo;s write a function that parses this data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseHeaders</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	WORD wValue, wNumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;IMAGE HEADERS&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Pointing now to the beging of the image
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Image magic number   =&gt; 0x%X (%.2s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_DOS_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>e_magic, (PCHAR) dwPtr);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NT headers RVA       =&gt; 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_DOS_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to the NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> ((PIMAGE_DOS_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NT headers signature =&gt; 0x%X (%s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>Signature, (PCHAR) dwPtr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;FILE HEADER&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Arch                       =&gt; &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> ( ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.Machine )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IMAGE_FILE_MACHINE_I386:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Intel x86&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IMAGE_FILE_MACHINE_IA64:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Intel Itanium&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IMAGE_FILE_MACHINE_AMD64:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;AMD x64&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;UNKNOWN&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Number of sections         =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Size of optional headers   =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.SizeOfOptionalHeader);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Save number of sections to be reused later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	wNumberOfSections <span style="color:#f92672">=</span> ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;OPTIONAL HEADER&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to the optional headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The state of the image file            =&gt; 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Magic);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The entrypoint RVA                     =&gt; 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfEntryPoint);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the code                   =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfCode);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the initialized data       =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfInitializedData);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the uninitialized data     =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfUninitializedData);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the image                  =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfImage);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the headers                =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfHeaders);	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;DATA DIRECTORY&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to data directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Number of directories
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	wValue <span style="color:#f92672">=</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Size</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">RVA&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all directories 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( wValue<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Move to the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;SECTIONS&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// AFTER OPTIONAL HEADERS COMES SECTION HEADERS, OUR dwPtr POINTS NOW TO THAT AREA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Section Name</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Section RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Size</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">PtrToRawData RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">SizeOfRawData</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Characteristics&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all sections
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( wNumberOfSections<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%.8s</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">  </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t\t\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Name,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Misc.VirtualSize,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>PointerToRawData,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfRawData
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> IMAGE_SCN_MEM_READ )
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;READABLE &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> IMAGE_SCN_MEM_WRITE )
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;WRITABLE &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> IMAGE_SCN_MEM_EXECUTE )
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;EXECUTABLE &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// New line
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Jump to the next section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_SECTION_HEADER);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="pe-imports">PE Imports</h2>
<p>This section is a very important section, to understand it we will go over the Data Directories located in <code>.idata</code>.</p>
<h3 id="import-directory-table">Import Directory Table</h3>
<p>The import directory table consists of an array of import directory entries, one entry for each DLL to which the image refers. The last directory entry is empty (filled with null values), which indicates the end of the directory table. Each import directory entry has the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_IMPORT_DESCRIPTOR {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        DWORD   Characteristics;
</span></span><span style="display:flex;"><span>        DWORD   OriginalFirstThunk;
</span></span><span style="display:flex;"><span>    } DUMMYUNIONNAME;
</span></span><span style="display:flex;"><span>    DWORD   TimeDateStamp;
</span></span><span style="display:flex;"><span>    DWORD   ForwarderChain;                
</span></span><span style="display:flex;"><span>    DWORD   Name;
</span></span><span style="display:flex;"><span>    DWORD   FirstThunk;  
</span></span><span style="display:flex;"><span>} IMAGE_IMPORT_DESCRIPTOR;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED <span style="color:#f92672">*</span>PIMAGE_IMPORT_DESCRIPTOR;
</span></span></code></pre></div><ul>
<li><strong>Characteristics|OriginalFirstThunk</strong>: The RVA of the Import Lookup|Name Table (ILT | INT)</li>
<li><strong>TimeDateStamp</strong>: After the image is bound, this field is set to the time/data stamp of the DLL.</li>
<li><strong>ForwarderChain</strong>: The index of the first forwarder reference or -1 if no forwarders. (forwarding means the DLL redirect some of its exported functions to another DLL).</li>
<li><strong>Name</strong>: The RVA of an ASCII string that contains the name of the DLL.</li>
<li><strong>FirstThunk</strong>: The RVA of the Import Address Table (IAT)</li>
</ul>
<h3 id="import-lookup-table">Import Lookup Table</h3>
<p>An import lookup table is an array of 32/64-bit numbers. The last entry is set to zero (NULL) to indicate the end of the table. Each entry uses the bit-field format as follows:</p>
<ul>
<li><strong>The most significant bit (MSB) 31/63</strong>: If this bit is set, import by ordinal. Otherwise, import by name.</li>
<li><strong>Ordinal Number 0-15</strong>: A 16-bit ordinal number. This field is used only if the Ordinal/Name Flag bit field is 1 (import by ordinal).</li>
<li><strong>Hint/Name 30-0</strong>: A 31-bit RVA of a hint/name table entry. This field is used only if the Ordinal/Name Flag bit field is 0 (import by name).</li>
</ul>
<h3 id="import-address-table">Import Address Table</h3>
<p>The structure and content of the import address table are identical to the import lookup table until the file is bound. During binding, the entries in the import address table are overwritten with the addresses of the symbols that are being imported. These addresses are the actual memory addresses of the symbols, although technically they are still called &ldquo;virtual addresses.&rdquo; The loader typically processes the binding.</p>
<h3 id="parse-imports">Parse Imports</h3>
<p>Let&rsquo;s develop a function that parses this section and obtains its valuable data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseImports</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpImportLookupTable;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpImportAddressTable;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpImportByName;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;IMPORT SECTION&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to Data Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Now pointing to Import Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY) <span style="color:#f92672">*</span> IMAGE_DIRECTORY_ENTRY_IMPORT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Return if there are no imports
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the import section (now pointing to import descriptors)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all import decriptors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PRINT_LINE</span>( (LPCSTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>Name), <span style="color:#ae81ff">50</span> );
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Get the ILT for current entry 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpImportLookupTable <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>OriginalFirstThunk);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Get the IAT for current entry 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpImportAddressTable <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>FirstThunk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Iterate over all IAT and ILT 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> ( <span style="color:#a6e22e">DEREF</span>(dwpImportAddressTable) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Check if the image imports by ordinal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> ( ((PIMAGE_THUNK_DATA) dwpImportLookupTable)<span style="color:#f92672">-&gt;</span>u1.Ordinal <span style="color:#f92672">&amp;</span> IMAGE_ORDINAL_FLAG )
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">- Ordinal =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">IMAGE_ORDINAL</span>(((PIMAGE_THUNK_DATA) dwpImportLookupTable)<span style="color:#f92672">-&gt;</span>u1.Ordinal));
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				dwpImportByName <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_THUNK_DATA) dwpImportLookupTable)<span style="color:#f92672">-&gt;</span>u1.AddressOfData);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">- Name    =&gt; %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (LPCSTR) ((PIMAGE_IMPORT_BY_NAME) dwpImportByName)<span style="color:#f92672">-&gt;</span>Name);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Next imported function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			dwpImportLookupTable <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD_PTR);
</span></span><span style="display:flex;"><span>			dwpImportAddressTable <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD_PTR);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Jump to the next descriptor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> ( ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>Name );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="pe-exports">PE Exports</h2>
<p>The export data section, named .edata, contains functions that have been exported and could be used by other programs that can be accessed through dynamic linking. Exported symbols are generally found in DLLs, but DLLs can also import symbols.</p>
<h3 id="export-directory-table">Export Directory Table</h3>
<p>As described by Microsoft documentation, the export symbol information begins with the export directory table, which describes the remainder of the export symbol information.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_EXPORT_DIRECTORY {
</span></span><span style="display:flex;"><span>	DWORD	Characteristics;
</span></span><span style="display:flex;"><span>	DWORD	TimeDateStamp;
</span></span><span style="display:flex;"><span>	WORD	MajorVersion;
</span></span><span style="display:flex;"><span>	WORD	MinorVersion;
</span></span><span style="display:flex;"><span>	DWORD	Name;
</span></span><span style="display:flex;"><span>	DWORD	Base;
</span></span><span style="display:flex;"><span>	DWORD	NumberOfFunctions;
</span></span><span style="display:flex;"><span>	DWORD	NumberOfNames;
</span></span><span style="display:flex;"><span>	DWORD	AddressOfFunctions;
</span></span><span style="display:flex;"><span>	DWORD	AddressOfNames;
</span></span><span style="display:flex;"><span>	DWORD	AddressOfNameOrdinals;
</span></span><span style="display:flex;"><span>} IMAGE_EXPORT_DIRECTORY,<span style="color:#f92672">*</span>PIMAGE_EXPORT_DIRECTORY;
</span></span></code></pre></div><ul>
<li><strong>Name</strong>: The RVA of the ASCII string that contains the name of the DLL.</li>
<li><strong>NumberOfFunctions</strong>: The number of entries in the export address table.</li>
<li><strong>NumberOfNames</strong>: The number of entries in the name pointer table. This is also the number of entries in the ordinal table.</li>
<li><strong>AddressOfFunctions</strong>: The RVA of the export address table.</li>
<li><strong>AddressOfNames</strong>: The RVA of the export name pointer table.</li>
<li><strong>AddressOfNameOrdinals</strong>: The RVA of the ordinal table.</li>
</ul>
<h3 id="export-address-table-eat">Export Address Table (EAT)</h3>
<p>An array of the RVA of exported function addresses.</p>
<h3 id="export-name-table">Export Name Table</h3>
<p>An array of the RVA of the exported function names.</p>
<h3 id="export-ordinal-table">Export Ordinal Table</h3>
<p>An array of the ordinal numbers, which are indexes of the function RVA within <strong>EAT</strong>, relative to its corresponding name. so if you want to retrieve the RVA of a function called <code>SayHello</code>, and its index inside <strong>Export Name Table</strong> is <strong>0</strong>, you can retrieve its index inside <strong>Export Address Table</strong> via <strong>Export Ordinal Table</strong> by name index which is zero.</p>
<h3 id="parse-exports">Parse Exports</h3>
<p>Let&rsquo;s develop a function that parses this section and obtains its valuable data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseExports</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpAddress;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpNames;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpOrdinals;
</span></span><span style="display:flex;"><span>	DWORD dwValue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;EXPORT SECTION&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to Data Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Now pointing to Export Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY) <span style="color:#f92672">*</span> IMAGE_DIRECTORY_ENTRY_EXPORT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check if there are no exports
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the export section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;DLL name                     =&gt; %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (LPCSTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Name));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Number of exported functions =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>NumberOfFunctions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get Addresses of names, ordinals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwpNames <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>	dwpOrdinals <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get number of names
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwValue <span style="color:#f92672">=</span> ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>NumberOfNames;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Name RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Address RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Ordinal</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Address</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">Name&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all EAT, Exported names, and ordinals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( dwValue<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Jump to EAT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpAddress <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Retrieve current function address by name ordinal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpAddress <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD_PTR) <span style="color:#f92672">*</span> <span style="color:#a6e22e">DEREF16</span>(dwpOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Display entry information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;0x%X</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">DEREF32</span>(dwpNames),  <span style="color:#75715e">// Name RVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">DEREF32</span>(dwpAddress), <span style="color:#75715e">// Address RVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">DEREF16</span>(dwpOrdinals), <span style="color:#75715e">// Ordinal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, <span style="color:#a6e22e">DEREF32</span>(dwpAddress)), <span style="color:#75715e">// Function Address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(LPCSTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, <span style="color:#a6e22e">DEREF32</span>(dwpNames)) <span style="color:#75715e">// Function Name 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next exported function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpNames <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD);
</span></span><span style="display:flex;"><span>		dwpOrdinals <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(WORD);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="pe-relocations">PE Relocations</h2>
<p>When the image is compiled, the compiler assumes that the executable will be loaded at a specific address, which is saved in the image&rsquo;s headers, as seen in <code>IMAGE_OPTIONAL_HEADER.ImageBase</code>. Based on this address, some addresses are calculated and hardcoded into the image. The problem arises because the loader is not limited to this hardcoded base address, it can load the image elsewhere, making the other addresses invalid. so those addresses need fixup which is the loader&rsquo;s responsibility. To understand the fixup process let&rsquo;s assume that the hardcoded based address is <strong>0x800000</strong> and we have a function whose RVA is <strong>0x800</strong>, then the function&rsquo;s address is <strong>0x800800</strong>, but what if the image gets loaded into <strong>0x808000</strong>, yep the function&rsquo;s address becomes invalid. For this issue to be fixed the loader overwrites the <strong>Relocation Blocks</strong> by calculating the delta between the actual memory address and the hardcoded address, so the loader calculates it as follows <code>0x808000 - 0x800000 = 0x8000</code>, then the loader adds this value to the old function&rsquo;s address <code>0x800800 + 0x8000</code> gives us the correct address which is <strong>0x808800</strong>.</p>
<h3 id="base-relocation-tableblocks">Base Relocation Table/Blocks</h3>
<p>The base relocation table contains entries for all base relocations in the image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_BASE_RELOCATION {
</span></span><span style="display:flex;"><span>    DWORD   VirtualAddress;
</span></span><span style="display:flex;"><span>    DWORD   SizeOfBlock;
</span></span><span style="display:flex;"><span>} IMAGE_BASE_RELOCATION;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED <span style="color:#f92672">*</span> PIMAGE_BASE_RELOCATION;
</span></span></code></pre></div><ul>
<li><strong>VirtualAddress</strong>: The image base plus the page RVA is added to each offset to create the VA where the base relocation must be applied.</li>
<li><strong>SizeOfBlock</strong>: The total number of bytes in the base relocation block, including the Page RVA and Block Size fields and the Type/Offset fields that follow.</li>
</ul>
<h3 id="parse-relocations">Parse Relocations</h3>
<p>Let&rsquo;s develop a function that parses this section and obtains its data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseRelocations</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpEntry;
</span></span><span style="display:flex;"><span>	DWORD dwNumberOfEntries;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;RELOCATION SECTION&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to Data Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Now pointing to Relocation Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY) <span style="color:#f92672">*</span> IMAGE_DIRECTORY_ENTRY_BASERELOC;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Return if there are no relocations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the reloc section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all relocation blocks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( ((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Calculate the number of entries inside this block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwNumberOfEntries <span style="color:#f92672">=</span> ( ((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock <span style="color:#f92672">-</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_BASE_RELOCATION) ) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(RELOC_ENTRY);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Display block information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Page RVA = 0x%X, Block Size = %d, Number Of Entries = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>			((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress,
</span></span><span style="display:flex;"><span>			((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock,
</span></span><span style="display:flex;"><span>			dwNumberOfEntries
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Pointing to the first entry in current block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpEntry <span style="color:#f92672">=</span> dwPtr <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_BASE_RELOCATION);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Iterate over all entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> ( dwNumberOfEntries<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Offset =&gt; 0x%X</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">Type   =&gt; 0x%X</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>				((PRELOC_ENTRY) dwpEntry)<span style="color:#f92672">-&gt;</span>w12Offset,
</span></span><span style="display:flex;"><span>				((PRELOC_ENTRY) dwpEntry)<span style="color:#f92672">-&gt;</span>w4Type
</span></span><span style="display:flex;"><span>			);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			dwpEntry <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(RELOC_ENTRY);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next relocation block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> ((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-full-code">The full code</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINT_LINE(str, n) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	printf(&#34;\n------%s&#34;, str); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	for (WORD i = 0; i &lt; n - strlen(str); i++) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		printf(&#34;-&#34;); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	puts(&#34;&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dereferencing macros
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define DEREF(addr)*(DWORD_PTR *)(addr)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEREF16(addr)*(WORD *)(addr)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEREF32(addr)*(DWORD *)(addr)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _RELOC_ENTRY {
</span></span><span style="display:flex;"><span>    WORD w12Offset : <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>    WORD w4Type : <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>} RELOC_ENTRY, <span style="color:#f92672">*</span> PRELOC_ENTRY;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DWORD <span style="color:#a6e22e">ResolveOffset</span>(LPVOID lpBaseAddress, DWORD dwRVA)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD dwNumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Nt Headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Retrieve number of sections from the file header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwNumberOfSections <span style="color:#f92672">=</span> ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the section header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader <span style="color:#f92672">+</span> ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.SizeOfOptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all sections header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( dwNumberOfSections<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check if the given RVA in the range of this section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>			 dwRVA <span style="color:#f92672">&gt;=</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex;"><span>			 dwRVA <span style="color:#f92672">&lt;</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">+</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfRawData
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Calculate the file offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> dwRVA <span style="color:#f92672">-</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">+</span> ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>PointerToRawData;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next section header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_SECTION_HEADER);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Invalid RVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseHeaders</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	WORD wValue, wNumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;IMAGE HEADERS&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Pointing now to the beging of the image
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Image magic number   =&gt; 0x%X (%.2s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_DOS_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>e_magic, (PCHAR) dwPtr);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NT headers RVA       =&gt; 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_DOS_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to the NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> ((PIMAGE_DOS_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NT headers signature =&gt; 0x%X (%s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>Signature, (PCHAR) dwPtr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Processing file header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;FILE HEADER&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Arch                       =&gt; &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> ( ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.Machine )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IMAGE_FILE_MACHINE_I386:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Intel x86&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IMAGE_FILE_MACHINE_IA64:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Intel Itanium&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> IMAGE_FILE_MACHINE_AMD64:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;AMD x64&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;UNKNOWN&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Number of sections         =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Size of optional headers   =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.SizeOfOptionalHeader);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Save number of sections to be reused later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	wNumberOfSections <span style="color:#f92672">=</span> ((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;OPTIONAL HEADER&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to the optional headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The state of the image file            =&gt; 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Magic);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The entrypoint RVA                     =&gt; 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfEntryPoint);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the code                   =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfCode);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the initialized data       =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfInitializedData);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the uninitialized data     =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfUninitializedData);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the image                  =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfImage);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The size of the headers                =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfHeaders);	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;DATA DIRECTORY&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to data directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_OPTIONAL_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Number of directories
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	wValue <span style="color:#f92672">=</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Size</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">RVA&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all directories 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( wValue<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Move to the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//****************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;SECTIONS&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// AFTER OPTIONAL HEADERS COMES SECTION HEADERS, OUR dwPtr POINTS NOW TO THAT AREA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Section Name</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Section RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Size</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">PtrToRawData RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">SizeOfRawData</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Characteristics&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all sections
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( wNumberOfSections<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%.8s</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">  </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t\t\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Name,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Misc.VirtualSize,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>PointerToRawData,
</span></span><span style="display:flex;"><span>			((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfRawData
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> IMAGE_SCN_MEM_READ )
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;READABLE &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> IMAGE_SCN_MEM_WRITE )
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;WRITABLE &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( ((PIMAGE_SECTION_HEADER) dwPtr)<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> IMAGE_SCN_MEM_EXECUTE )
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;EXECUTABLE &#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// New line
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Jump to the next section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_SECTION_HEADER);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseImports</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpImportLookupTable;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpImportAddressTable;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpImportByName;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;IMPORT SECTION&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to Data Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Now pointing to Import Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY) <span style="color:#f92672">*</span> IMAGE_DIRECTORY_ENTRY_IMPORT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Return if there are no imports
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the import section (now pointing to import descriptors)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all import decriptors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PRINT_LINE</span>( (LPCSTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>Name), <span style="color:#ae81ff">50</span> );
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Get the ILT for current entry 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpImportLookupTable <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>OriginalFirstThunk);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Get the IAT for current entry 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpImportAddressTable <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>FirstThunk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Iterate over all IAT and ILT 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> ( <span style="color:#a6e22e">DEREF</span>(dwpImportAddressTable) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Check if the image imports by ordinal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> ( ((PIMAGE_THUNK_DATA) dwpImportLookupTable)<span style="color:#f92672">-&gt;</span>u1.Ordinal <span style="color:#f92672">&amp;</span> IMAGE_ORDINAL_FLAG )
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">- Ordinal =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">IMAGE_ORDINAL</span>(((PIMAGE_THUNK_DATA) dwpImportLookupTable)<span style="color:#f92672">-&gt;</span>u1.Ordinal));
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				dwpImportByName <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_THUNK_DATA) dwpImportLookupTable)<span style="color:#f92672">-&gt;</span>u1.AddressOfData);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">- Name    =&gt; %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (LPCSTR) ((PIMAGE_IMPORT_BY_NAME) dwpImportByName)<span style="color:#f92672">-&gt;</span>Name);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Next imported function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			dwpImportLookupTable <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD_PTR);
</span></span><span style="display:flex;"><span>			dwpImportAddressTable <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD_PTR);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Jump to the next descriptor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> ( ((PIMAGE_IMPORT_DESCRIPTOR) dwPtr)<span style="color:#f92672">-&gt;</span>Name );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseExports</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpAddress;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpNames;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpOrdinals;
</span></span><span style="display:flex;"><span>	DWORD dwValue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;EXPORT SECTION&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to Data Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Now pointing to Export Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY) <span style="color:#f92672">*</span> IMAGE_DIRECTORY_ENTRY_EXPORT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check if there are no exports
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the export section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;DLL name                     =&gt; %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (LPCSTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Name));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Number of exported functions =&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>NumberOfFunctions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get Addresses of names, ordinals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwpNames <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>	dwpOrdinals <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get number of names
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwValue <span style="color:#f92672">=</span> ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>NumberOfNames;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Name RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Address RVA</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Ordinal</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Address</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">Name&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all EAT, Exported names, and ordinals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( dwValue<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Jump to EAT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpAddress <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_EXPORT_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Retrieve current function address by name ordinal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpAddress <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD_PTR) <span style="color:#f92672">*</span> <span style="color:#a6e22e">DEREF16</span>(dwpOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Display entry information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;0x%X</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">0x%X</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">DEREF32</span>(dwpNames),  <span style="color:#75715e">// Name RVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">DEREF32</span>(dwpAddress), <span style="color:#75715e">// Address RVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">DEREF16</span>(dwpOrdinals), <span style="color:#75715e">// Ordinal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, <span style="color:#a6e22e">DEREF32</span>(dwpAddress)), <span style="color:#75715e">// Function Address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(LPCSTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, <span style="color:#a6e22e">DEREF32</span>(dwpNames)) <span style="color:#75715e">// Function Name 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next exported function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpNames <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(DWORD);
</span></span><span style="display:flex;"><span>		dwpOrdinals <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(WORD);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#a6e22e">ParseRelocations</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD_PTR dwPtr;
</span></span><span style="display:flex;"><span>	DWORD_PTR dwpEntry;
</span></span><span style="display:flex;"><span>	DWORD dwNumberOfEntries;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PRINT_LINE</span>(<span style="color:#e6db74">&#34;RELOCATION SECTION&#34;</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to NT headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to Data Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) <span style="color:#f92672">&amp;</span>((PIMAGE_NT_HEADERS) dwPtr)<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Now pointing to Relocation Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DATA_DIRECTORY) <span style="color:#f92672">*</span> IMAGE_DIRECTORY_ENTRY_BASERELOC;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Return if there are no relocations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>Size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Jump to the reloc section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwPtr <span style="color:#f92672">=</span> (DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> <span style="color:#a6e22e">ResolveOffset</span>(lpBaseAddress, ((PIMAGE_DATA_DIRECTORY) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Iterate over all relocation blocks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ( ((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Calculate the number of entries inside this block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwNumberOfEntries <span style="color:#f92672">=</span> ( ((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock <span style="color:#f92672">-</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_BASE_RELOCATION) ) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(RELOC_ENTRY);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Display block information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Page RVA = 0x%X, Block Size = %d, Number Of Entries = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>			((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>VirtualAddress,
</span></span><span style="display:flex;"><span>			((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock,
</span></span><span style="display:flex;"><span>			dwNumberOfEntries
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Pointing to the first entry in current block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwpEntry <span style="color:#f92672">=</span> dwPtr <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_BASE_RELOCATION);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Iterate over all entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> ( dwNumberOfEntries<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Offset =&gt; 0x%X</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">Type   =&gt; 0x%X</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>				((PRELOC_ENTRY) dwpEntry)<span style="color:#f92672">-&gt;</span>w12Offset,
</span></span><span style="display:flex;"><span>				((PRELOC_ENTRY) dwpEntry)<span style="color:#f92672">-&gt;</span>w4Type
</span></span><span style="display:flex;"><span>			);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			dwpEntry <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(RELOC_ENTRY);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next relocation block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dwPtr <span style="color:#f92672">+=</span> ((PIMAGE_BASE_RELOCATION) dwPtr)<span style="color:#f92672">-&gt;</span>SizeOfBlock;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">ParsePE</span>(LPVOID lpBaseAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check if a valid PE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>(
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check the DOS header signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		( ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">==</span> IMAGE_DOS_SIGNATURE ) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check if the RVA of the NT headers in the expected range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		( ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">sizeof</span>(IMAGE_DOS_HEADER) <span style="color:#f92672">&amp;&amp;</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x400</span> ) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check the NT header signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		( ((PIMAGE_NT_HEADERS)((DWORD_PTR) lpBaseAddress <span style="color:#f92672">+</span> ((PIMAGE_DOS_HEADER) lpBaseAddress)<span style="color:#f92672">-&gt;</span>e_lfanew))<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">==</span> IMAGE_NT_SIGNATURE )
</span></span><span style="display:flex;"><span>	))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ParseHeaders</span>(lpBaseAddress);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ParseImports</span>(lpBaseAddress);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ParseExports</span>(lpBaseAddress);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ParseRelocations</span>(lpBaseAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LPVOID <span style="color:#a6e22e">ReadPEFile</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpFileName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HANDLE hFile <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	LPVOID lpBuffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	DWORD dwSize, dwRead;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get a handle on the file with some attributes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hFile <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>( cpFileName, GENERIC_READ, <span style="color:#ae81ff">0</span>, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If the given PE file doesn&#39;t exist, return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( hFile <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	dwSize <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetFileSize</span>(hFile, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If the given PE file was empty or invalid, close the file handle, return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( dwSize <span style="color:#f92672">==</span> INVALID_FILE_SIZE <span style="color:#f92672">||</span> dwSize <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Allocate sufficient memory for the PE in the main heap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	lpBuffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">HeapAlloc</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, dwSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If allocation request failed, return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> lpBuffer )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Read the PE file in the allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">ReadFile</span>(hFile, lpBuffer, dwSize, <span style="color:#f92672">&amp;</span>dwRead, NULL) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If we failed to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// Deallocate the memory, close the file handle, and return NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpBuffer);
</span></span><span style="display:flex;"><span>		lpBuffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LEAVE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( hFile ) <span style="color:#a6e22e">CloseHandle</span>(hFile);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> lpBuffer;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	LPVOID lpBuffer;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> nRet <span style="color:#f92672">=</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( argc <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Usage:</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">./PEParser &lt;/path/to/pefile&gt;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	lpBuffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">ReadPEFile</span>(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>lpBuffer )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed to read %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">ParsePE</span>(lpBuffer) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Invalid PE file&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> LEAVE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nRet <span style="color:#f92672">=</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LEAVE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( lpBuffer ) <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpBuffer);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> nRet;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s parse AMSI DLL and see the results.</p>
<pre tabindex="0"><code>C:\path\to&gt;PEParser.exe c:\Windows\System32\amsi.dll

------IMAGE HEADERS---------------------------------------------------------------------------------------
Image magic number   =&gt; 0x5A4D (MZ)
NT headers RVA       =&gt; 0xF8
NT headers signature =&gt; 0x4550 (PE)

------FILE HEADER-----------------------------------------------------------------------------------------
Arch                       =&gt; Intel x86
Number of sections         =&gt; 6
Size of optional headers   =&gt; 224

------OPTIONAL HEADER-------------------------------------------------------------------------------------
The state of the image file            =&gt; 0x10B
The entrypoint RVA                     =&gt; 0xED00
The size of the code                   =&gt; 65024
The size of the initialized data       =&gt; 18944
The size of the uninitialized data     =&gt; 0
The size of the image                  =&gt; 102400
The size of the headers                =&gt; 1024

------DATA DIRECTORY--------------------------------------------------------------------------------------
Size            RVA
396             0x10BC0
480             0x12204
5096            0x15000
0               0x0
0               0x0
4452            0x17000
84              0x3460
0               0x0
0               0x0
0               0x0
172             0x1698
0               0x0
512             0x12000
128             0x109E0
0               0x0
0               0x0

------SECTIONS--------------------------------------------------------------------------------------------
Section Name    Section RVA     Size    PtrToRawData RVA        SizeOfRawData   Characteristics
.text           0x1000          64844   0x400                   65024           READABLE EXECUTABLE
.data           0x11000         3636    0x10200                 2048            READABLE WRITABLE
.idata          0x12000         4294    0x10A00                 4608            READABLE
.didat          0x14000         56      0x11C00                 512             READABLE WRITABLE
.rsrc           0x15000         5096    0x11E00                 5120            READABLE
.reloc          0x17000         4452    0x13200                 4608            READABLE

------IMPORT SECTION--------------------------------------------------------------------------------------

------msvcrt.dll----------------------------------------
        - Name    =&gt; memcpy_s
        - Name    =&gt; memmove
        - Name    =&gt; srand
        - Name    =&gt; memcpy
        - Name    =&gt; _CxxThrowException
        - Name    =&gt; ?what@exception@@UBEPBDXZ
        - Name    =&gt; ??0exception@@QAE@ABQBDH@Z
        - Name    =&gt; ??0exception@@QAE@ABQBD@Z
        - Name    =&gt; _callnewh
        - Name    =&gt; rand
        - Name    =&gt; memmove_s
        - Name    =&gt; _purecall
        - Name    =&gt; _vsnprintf_s
        - Name    =&gt; memcmp
        - Name    =&gt; wcsnlen
        - Name    =&gt; ??1type_info@@UAE@XZ
        - Name    =&gt; _onexit
        - Name    =&gt; __dllonexit
        - Name    =&gt; _unlock
        - Name    =&gt; ??0exception@@QAE@XZ
        - Name    =&gt; _lock
        - Name    =&gt; ?terminate@@YAXXZ
        - Name    =&gt; _except_handler4_common
        - Name    =&gt; ??3@YAXPAX@Z
        - Name    =&gt; _vsnwprintf
        - Name    =&gt; _initterm
        - Name    =&gt; _amsg_exit
        - Name    =&gt; ??_V@YAXPAX@Z
        - Name    =&gt; _XcptFilter
        - Name    =&gt; __CxxFrameHandler3
        - Name    =&gt; malloc
        - Name    =&gt; ??1exception@@UAE@XZ
        - Name    =&gt; ??0exception@@QAE@ABV0@@Z
        - Name    =&gt; free
        - Name    =&gt; time
        - Name    =&gt; memset

------api-ms-win-core-synch-l1-1-0.dll------------------
        - Name    =&gt; ReleaseSRWLockShared
        - Name    =&gt; DeleteCriticalSection
        - Name    =&gt; OpenSemaphoreW
        - Name    =&gt; AcquireSRWLockExclusive
        - Name    =&gt; WaitForSingleObjectEx
        - Name    =&gt; ReleaseSRWLockExclusive
        - Name    =&gt; WaitForSingleObject
        - Name    =&gt; ReleaseSemaphore
        - Name    =&gt; CreateSemaphoreExW
        - Name    =&gt; AcquireSRWLockShared
        - Name    =&gt; CreateMutexExW
        - Name    =&gt; ReleaseMutex
        - Name    =&gt; InitializeCriticalSection
        - Name    =&gt; LeaveCriticalSection
        - Name    =&gt; EnterCriticalSection
        - Name    =&gt; InitializeCriticalSectionEx

------api-ms-win-eventing-provider-l1-1-0.dll-----------
        - Name    =&gt; EventSetInformation
        - Name    =&gt; EventProviderEnabled
        - Name    =&gt; EventRegister
        - Name    =&gt; EventUnregister
        - Name    =&gt; EventWriteTransfer
        - Name    =&gt; EventWrite

------api-ms-win-eventing-classicprovider-l1-1-0.dll----
        - Name    =&gt; GetTraceLoggerHandle
        - Name    =&gt; GetTraceEnableFlags
        - Name    =&gt; UnregisterTraceGuids
        - Name    =&gt; RegisterTraceGuidsW
        - Name    =&gt; GetTraceEnableLevel
        - Name    =&gt; TraceMessage

------api-ms-win-core-errorhandling-l1-1-0.dll----------
        - Name    =&gt; UnhandledExceptionFilter
        - Name    =&gt; SetUnhandledExceptionFilter
        - Name    =&gt; SetLastError
        - Name    =&gt; GetLastError

------api-ms-win-core-libraryloader-l1-2-0.dll----------
        - Name    =&gt; GetProcAddress
        - Name    =&gt; GetModuleHandleExW
        - Name    =&gt; GetModuleFileNameA
        - Name    =&gt; LoadLibraryExW
        - Name    =&gt; GetModuleHandleW

------api-ms-win-core-heap-l1-1-0.dll-------------------
        - Name    =&gt; HeapFree
        - Name    =&gt; HeapAlloc
        - Name    =&gt; GetProcessHeap

------api-ms-win-core-processthreads-l1-1-0.dll---------
        - Name    =&gt; TerminateProcess
        - Name    =&gt; GetCurrentThreadId
        - Name    =&gt; GetCurrentProcessId
        - Name    =&gt; GetCurrentProcess

------api-ms-win-core-localization-l1-2-0.dll-----------
        - Name    =&gt; FormatMessageW

------api-ms-win-core-debug-l1-1-0.dll------------------
        - Name    =&gt; DebugBreak
        - Name    =&gt; OutputDebugStringW
        - Name    =&gt; IsDebuggerPresent

------api-ms-win-core-synch-l1-2-0.dll------------------
        - Name    =&gt; Sleep

------api-ms-win-core-profile-l1-1-0.dll----------------
        - Name    =&gt; QueryPerformanceCounter

------api-ms-win-core-sysinfo-l1-1-0.dll----------------
        - Name    =&gt; GetTickCount
        - Name    =&gt; GetSystemTimeAsFileTime

------RPCRT4.dll----------------------------------------
        - Name    =&gt; UuidFromStringW

------api-ms-win-core-registry-l1-1-0.dll---------------
        - Name    =&gt; RegCloseKey
        - Name    =&gt; RegOpenKeyExW
        - Name    =&gt; RegEnumKeyExW
        - Name    =&gt; RegQueryInfoKeyW
        - Name    =&gt; RegGetValueW

------api-ms-win-core-sysinfo-l1-2-0.dll----------------
        - Name    =&gt; GetSystemTimePreciseAsFileTime

------api-ms-win-core-threadpool-l1-2-0.dll-------------
        - Name    =&gt; SetThreadpoolTimer
        - Name    =&gt; CloseThreadpoolTimer
        - Name    =&gt; CreateThreadpoolTimer
        - Name    =&gt; WaitForThreadpoolTimerCallbacks

------api-ms-win-core-file-l1-1-0.dll-------------------
        - Name    =&gt; CreateFileW

------api-ms-win-core-processthreads-l1-1-1.dll---------
        - Name    =&gt; OpenProcess

------api-ms-win-core-handle-l1-1-0.dll-----------------
        - Name    =&gt; CloseHandle

------api-ms-win-core-delayload-l1-1-1.dll--------------
        - Name    =&gt; ResolveDelayLoadedAPI

------api-ms-win-core-delayload-l1-1-0.dll--------------
        - Name    =&gt; DelayLoadFailureHook

------ntdll.dll-----------------------------------------
        - Name    =&gt; NtQueryInformationProcess

------EXPORT SECTION--------------------------------------------------------------------------------------
DLL name                     =&gt; Amsi.dll
Number of exported functions =&gt; 13

Name RVA        Address RVA     Ordinal Address         Name
0x10C73         0x59D0          0x0     0x52AD90        AmsiCloseSession
0x10C84         0x56B0          0x1     0x52AA70        AmsiInitialize
0x10C93         0x5970          0x2     0x52AD30        AmsiOpenSession
0x10CA3         0x5A00          0x3     0x52ADC0        AmsiScanBuffer
0x10CB2         0x5AB0          0x4     0x52AE70        AmsiScanString
0x10CC1         0x5B00          0x5     0x52AEC0        AmsiUacInitialize
0x10CD3         0x5D20          0x6     0x52B0E0        AmsiUacScan
0x10CDF         0x5CD0          0x7     0x52B090        AmsiUacUninitialize
0x10CF3         0x5920          0x8     0x52ACE0        AmsiUninitialize
0x10D04         0x4600          0x9     0x5299C0        DllCanUnloadNow
0x10D14         0x4630          0xA     0x5299F0        DllGetClassObject
0x10D26         0x4660          0xB     0x529A20        DllRegisterServer
0x10D38         0x4660          0xC     0x529A20        DllUnregisterServer

------RELOCATION SECTION----------------------------------------------------------------------------------
Page RVA = 0x1000, Block Size = 952, Number Of Entries = 472
        Offset =&gt; 0x0
        Type   =&gt; 0x3

        Offset =&gt; 0x4
        Type   =&gt; 0x3

        Offset =&gt; 0x8
        Type   =&gt; 0x3

        Offset =&gt; 0xC
        Type   =&gt; 0x3

        Offset =&gt; 0x10
        Type   =&gt; 0x3

        Offset =&gt; 0x14
        Type   =&gt; 0x3

        Offset =&gt; 0x18
        Type   =&gt; 0x3

        Offset =&gt; 0x24
        Type   =&gt; 0x3

        Offset =&gt; 0x2C
        Type   =&gt; 0x3

        Offset =&gt; 0x34
        Type   =&gt; 0x3

        Offset =&gt; 0x3C
        Type   =&gt; 0x3

        Offset =&gt; 0x44
        Type   =&gt; 0x3
        .
        ..
        ...
        ..... (A LOT OF ENTRIES)
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>Try playing with tools such as dumpbin and PEBear and develop your parser to solidify your understanding, I know the topic is a little bit complicated, but practice always is key.  Thank you for joining me on this exploration.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
         | 
        <a href="https://www.linkedin.com/in/0xNinjaCyclone">Linkedin</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
