<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 04- Understanding Binary Files | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 04- Understanding Binary Files</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2023-12-29</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 879 words</span>
  <span> • 5 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/binary-file">binary-file</a>, 
        <a href="/tags/pe">pe</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p>Hello everyone, I hope you&rsquo;re all well. In this article, we&rsquo;re going to talk about binary files. We&rsquo;ll look at how they are built, what they contain, their structure, and the information contained within each part. the importance of this information,  the role of each piece of information, and how we can read and understand it using specialized tools. Understanding the architecture of binary files is vital for reverse engineering and the process of debugging and analyzing the software to determine what it does so you can break it. Also, this is very important for developing custom shellcodes as we&rsquo;ll see in the upcoming articles.</p>
<h2 id="executable-binary-file">Executable binary file</h2>
<p>A binary file or portable executable file is a file whose content is in a binary format consisting of a series of sequential bytes. It contains not only the executable instructions that can be executed directly by the CPU, but also a lot of information that helps the OS to manage and load it correctly into the memory, to be executed, and more. Executable binary files include a wide range of file types, including executables ( .exe, .elf ), libraries ( .dll, .so ), control panel applications ( .cpl ), Kernel modules ( .srv, .ko ), and many others.</p>
<h2 id="building-phases">Building phases</h2>
<p>Executable binary file goes through several phases to be built. so let&rsquo;s write a simple program, to show you those phases and where our data goes in the final binary file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define OS &#34;Windows&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#elif __linux__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define OS &#34;Linux&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#elif __unix__ 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define OS &#34;Unix&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#elif __APPLE__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define OS &#34;Apple&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define OS &#34;Unknown&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> g_cData[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;This is a test program&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>( <span style="color:#e6db74">&#34;Hello World from &#34;</span> OS );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>( g_cData );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="preprocessing-phase">Preprocessing phase</h3>
<p>Source code Preprocessing is the first phase in the compilation process, the preprocessor is not a part of the compiler but is a separate step in the compilation process. The preprocessing is just a text substitution. All preprocessor commands begin with a hash symbol (#) such as <code>#include</code>, <code>#define</code>, and <code>#ifdef</code>. so the above source code each <code>directive</code> and <code>macro</code> will be replaced with its actual content, after this process if compiled on Linux OS our code will look like the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    THE ACTUAL CONTENT OF stdio.h ( WITH ITS DEPENDENCIES )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> g_cData[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;This is a test program&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>( <span style="color:#e6db74">&#34;Hello World from &#34;</span> <span style="color:#e6db74">&#34;Linux&#34;</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>( g_cData );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can use <code>gcc -E</code> to only run the preprocessor part.</p>
<h3 id="compiling-phase">Compiling phase</h3>
<p>This phase is done via several steps aimed for generating assembly code for the targeted architecture. You can use <code>gcc -S</code> to only run the compiler part.</p>
<h3 id="assembling-phase">Assembling phase</h3>
<p>This phase aims to convert the output of the compiler into machine language. its output is an object file containing not only the executable section but also some information helpful for the linker which is the next phase. You can use <code>gcc -c</code> to only run the assembler without getting into the linking phase.</p>
<h3 id="linking-phase">Linking phase</h3>
<p>Linking is a process of collecting and maintaining object modules and combining them into a single executable file that can be loaded by the OS loader and then executed. There are two types of linking, static linking which aims to embed the library within the final executable file, and dynamic linking which is performed during the run time.</p>
<h2 id="executable-binary-structure">Executable binary structure</h2>
<p>The Executable binary structure is not much different between Windows and Linux. We will cover the main parts of the Executable binary files.</p>
<h3 id="executable-binary-headers">Executable binary Headers</h3>
<p>The first part of the executable binary files consists of headers that contain data assisting the OS loader in loading the program into memory. There are data such as <strong>the Initial Stack Pointer value</strong>, <strong>Initial Instruction Pointer value</strong>, <strong>the type of machine (CPU Architecture)</strong>, <strong>the number of the sections</strong>, <strong>the size of the stack/heap to reserve</strong>, some description about sections, and a lot more information.</p>
<p>You can read headers information using <strong>readelf</strong> on Linux as follows:</p>
<pre tabindex="0"><code>readelf --headers &lt;pefile&gt;
</code></pre><p>Or you can use the following command on Windows (inside the Visual Studio prompt) as follows:</p>
<pre tabindex="0"><code>dumpbin /headers &lt;pefile&gt;
</code></pre><h3 id="sections">Sections</h3>
<p>Sections are the actual data containers of the executable file. There are many sections for different purposes, their number is specified in the headers, and their names may differ slightly between operating systems.</p>
<ul>
<li><strong>.text|.code</strong>: Contains the executable code of the program.</li>
<li><strong>.data</strong>: Contains the initialized data.</li>
<li><strong>.rdata|.rodata</strong>: Contains the read-only data.</li>
<li><strong>.bss</strong>: Contains the uninitialized global data.</li>
<li><strong>.tls|(.tbss,.tdata)</strong>: Similar to <strong>.bss</strong> section, but for Thread-Local data.</li>
<li><strong>.idata|(.dynstr&amp;.dynsym)</strong>: Contains the import tables.</li>
<li><strong>.edata|(.dynstr&amp;.dynsym)</strong>: Contains the export tables.</li>
<li><strong>.reloc|.rela</strong>: Contains the image relocation information.</li>
<li><strong>.debug|.debug_XXX</strong> : Contains the debugging information.</li>
</ul>
<p>Those are the most important sections, we can parse them on Linux as follows:</p>
<pre tabindex="0"><code>readelf -t &lt;pefile&gt;
readelf -p &lt;section-name|section-number&gt; &lt;pefile&gt;
readelf -x &lt;section-name|section-number&gt; &lt;pefile&gt;

# dump section
objcopy -O binary --only-section=&lt;section-name&gt; &lt;pefile&gt; &lt;output&gt;
</code></pre><p>Or as following on Windows:</p>
<pre tabindex="0"><code>dumpbin /SECTION:&lt;section-name&gt; &lt;pefile&gt;
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>In this article, we looked at a basic overview of the executable binary files talked briefly about the process of building them, and looked at their architecture, and the information inside each part. In the following articles, we’ll talk about those parts in much more detail, and we&rsquo;ll learn how we can deal with them programmatically.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
         | 
        <a href="https://www.linkedin.com/in/0xNinjaCyclone">Linkedin</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
