<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 02- Understanding Stack Memory | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 02- Understanding Stack Memory</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2023-12-13</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 2403 words</span>
  <span> • 12 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/stack">stack</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p>Hello everyone, I hope you are well. In this article, we will discuss the stack, why any computer program needs it, what vital role it plays, and how it works in detail. We will explore the operations performed on the stack and how they are handled. Understanding the stack will pave the way for us in the exploit development field and other fields like reverse engineering and malware development.</p>
<h2 id="overview">Overview</h2>
<p>Any computer program to accomplish its task needs some resources such as memory for storing and manipulating some data at runtime, CPU time for executing its logic, and IO interfaces to interact with for retrieving data from devices such as mouse and keyboard and export data to them, etc. These program&rsquo;s requirements are controlled and managed by the Operating System itself, and the program is relieved of the trouble of dealing with them itself. That provides ease and simplicity and protects the system from many risks. However, the program must be careful and intelligent when interacting and dealing with those components. When a computer program takes time to execute on the central process unit, it must cooperate in some way with the CPU and provide it with the data required to perform operations on it. It must also have a dedicated memory to store the outputs without conflicting with other data or losing anything. The operating system provides programs with the memory they need. However, the OS does not care how that memory gets managed later. That leaves the responsibility of managing local memory to the programs themselves. What we are discussing reinforces the need for a method or mechanism to dynamically manage data in temporary memory and makes interaction with the CPU easier and more effective.</p>
<h2 id="what-is-stack">What is Stack?</h2>
<p>When you think about how any computer program executes its logic, you&rsquo;ll find that there is a root function that calls other functions, and other functions call other functions, like a tree. It is never possible for a parent function to end before the child one because every child function is considered an integral part of the parent one. For this reason, a parent function can&rsquo;t end before the child one because it actually depends on the result of the child function. For example, in the C language, execution begins with the <code>main</code> function, and this <code>main</code> function calls sub-functions. The sub-functions call others until everyone finishes their task, and the <code>main</code> function finishes last. Isn&rsquo;t this a last-in-first-out (LIFO) concept?</p>
<p>The stack is a temporary memory that behaves as a first-in-last-out buffer, divided into a group of frames on top of each other. Each stack frame stores data such as parameters, local variables, and other temporary things for a particular function. You can imagine the stack as an array, but the insertion is done in reverse order. That means the first frame will be at the last position, and the next one will be before it and keep growing backward. The stack size needed by the program is calculated by the compiler at compile time depending on the requirements of the program, the size of its temporary data, and the operations it performs. There are two very important elements that you should know, which are base pointer (BP) and stack pointer (SP), as the CPU relies heavily on them to access the data required to perform operations on it.</p>
<h2 id="the-base-pointer-bp">The base pointer (BP)</h2>
<p>The stack base pointer is a register that refers to the bottom of the stack frame during function calls. Which normally refers to higher addresses as it grows towards lower. When you think of the stack horizontally as an array, this register should hold the address of the end of the frame or that array item. Data inside the stack, such as local variables and function parameters, can be located and accessed by their offsets relative to the BP.</p>
<h2 id="the-stack-pointer-sp">The stack pointer (SP)</h2>
<p>The stack pointer is a register that refers to the top of the stack frame during function calls. Which normally refers to lower addresses. The SP specifies the beginning of the frame, which means the SP points to a position lower than that BP points to when you look at the stack as an array. This register is also used to locate and access the function&rsquo;s data based on their offsets within the frame relative to the SP.</p>
<p>The stack pointer can freely move when data is dynamically pushed onto the stack. But any data stored within the stack and every push instruction executed must be accompanied by a corresponding pop-off operation. Otherwise, the program will end up crashing.</p>
<h2 id="the-stack-frame">The stack frame</h2>
<p>The stack frame is actually a small piece of memory belonging to the stack dedicated to serving a particular function, and each frame size is calculated by the compiler at compile time depending on the data contained by that particular function.</p>
<p>When any function gets called, a new stack frame is initialized above the caller&rsquo;s stack frame or before the caller&rsquo;s frame if you look at the stack horizontally as an array. This new frame is used to store the function&rsquo;s data such as variables and parameters, as we said before. The BP is pushed onto the stack to save the base address of the caller&rsquo;s frame for later retrieval, as well as the return address of the function which tells the CPU what next instruction to execute after the current function finishes its task. When the function completes its execution, it should return to the caller, and that new stack frame will be deleted, and both the BP and the return address will be popped off.</p>
<p>There is a point I want to mention here, which is that deleting a stack frame does not necessarily mean getting rid of its content. What will happen is just moving the pointers that mark the beginning and end of the frame, which are the BP and SP. That means the function&rsquo;s data will remain within the stack until another new frame overwrites it.</p>
<h2 id="how-software-deal-with-the-stack">How software deal with the stack?</h2>
<p>Let&rsquo;s write a simple C code and show you what the stack looks like and how the program handles the stack:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcX</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcX&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcY</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcY&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">funcX</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">funcY</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a simple program that has 3 functions the main function which is the entry point, funcX, funcY, both of them display a Hello message on the screen, when funcX gets called we expect that a new stack frame will be created above the main&rsquo;s stack frame and both the return address and BP are pushed onto the stack, so let&rsquo;s see what happens:</p>
<center><img src="/imgs/dbg_stack.png" width="512"/></center>
<p>As you see in the picture when the funcX was called, following things happened.</p>
<ul>
<li>The function’s return address is pushed onto the stack so the CPU can remember the next instruction after calling the <code>funcX</code> to resume the <code>main</code> function execution after <code>funcX</code> completes its execution.</li>
<li>The BP that marks the bottom of the main stack frame is pushed onto the stack so the program can remember it later when the function finishes. Then, the BP jumps up to the SP position, and the SP will be automatically brought up and down when temporary data is pushed and popped-off. That&rsquo;s literally how a new stack frame gets initialized.</li>
<li>When <code>funcX</code> finishes its execution, both BP and SP will be pointing at the bottom of the <code>funcX</code>&rsquo;s stack frame, which is the top of the main stack frame. So, the SP refers to the correct offset, but the BP does not. That&rsquo;s why the BP had been pushed onto the stack. So, the program will pop off the BP to remember the bottom of the main stack frame. After that, the function&rsquo;s return address will be popped off automatically so the CPU remembers the next instruction within the caller function to resume the execution of the main function.</li>
</ul>
<p>After that, the execution flow will return to the main function. When the CPU pops off the instruction pointer from the stack, it will find it pointing to an instruction in the main function. The main function also contains a call to function Y. When this function gets called, a new stack frame is created in the same position as the function&rsquo;s X stack frame. Then, function Y puts its own data and replaces the old data, and the same cycle that we explained previously is repeated.</p>
<h2 id="illustration-showing-how-the-stack-works">Illustration showing how the stack works</h2>
<p>This illustration demonstrates how the stack behaves with the code we explained above:</p>
<center><img src="/imgs/stack.png" width="512"/></center>
<h2 id="advanced-benefits-of-return-address">Advanced benefits of return address</h2>
<p>Did you ask yourself before how tools such as process hacker can track the execution of the programs and know exactly the chain of calls, How do AV/EDRs analyze the programs during execution and detect either malicious or not?</p>
<p>The <strong>return address</strong> is the reason, these tools grab the return addresses via walking through the stack frames, Each stack frame has a base pointer of the previous stack frame as we said before, Which makes it like a <a href="https://github.com/0xNinjaCyclone/dalgo/blob/master/DS/llist.c">linked list</a> data structure.</p>
<p>Let&rsquo;s write a simple C code and show you what i mean.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcC</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcC&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcB</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcB&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcC</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcA</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcA&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcB</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from main&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcA</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you see four functions call each other as following, main-&gt;funcA-&gt;funcB-&gt;funcC, Let&rsquo;s see how process hacker can track this flow.</p>
<center><img src="/imgs/ph_stack.png" width="512"/></center>
<p>What such programs do to track function calls is to walk through the stack frames and grab the functions&rsquo; return address, which helps in identifying who is calling whom. So let&rsquo;s try to do it ourselves. First, we need to develop our assembly function that retrieves return addresses from the stack frames.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Author =&gt; Abdallah Mohamed ( 0xNinjaCyclone )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.386</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.MODEL</span> <span style="color:#66d9ef">flat</span>, <span style="color:#66d9ef">c</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.code</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">GrabRetAddresses</span> <span style="color:#66d9ef">proc</span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">edx</span>, [<span style="color:#66d9ef">esp</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">4</span>]       <span style="color:#75715e">; Where the results will be stored
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, [<span style="color:#66d9ef">esp</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">8</span>]       <span style="color:#75715e">; Number of addresses to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>             <span style="color:#75715e">; bSuccess = FALSE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">ebp</span>             <span style="color:#75715e">; BP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	grab:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dec</span> <span style="color:#66d9ef">ecx</span>                  <span style="color:#75715e">; dwSize--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">esi</span>, [<span style="color:#66d9ef">ebx</span>]           <span style="color:#75715e">; Previous BP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edi</span>, [<span style="color:#66d9ef">ebx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">4</span>]       <span style="color:#75715e">; Return Address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">esi</span>            <span style="color:#75715e">; We have to stop if we reach the stack base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">jz</span> <span style="color:#66d9ef">finish</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">edx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">ecx</span> * <span style="color:#ae81ff">4</span>], <span style="color:#66d9ef">edi</span> <span style="color:#75715e">; pResult[dwSize] = pRetAddr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">esi</span>             <span style="color:#75715e">; Bring down to the next stack frame
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>            <span style="color:#75715e">; Stop if we completed our task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">grab</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">eax</span>                  <span style="color:#75715e">; bSuccess = TRUE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	finish:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span>                      <span style="color:#75715e">; return to the caller
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">GrabRetAddresses</span> <span style="color:#66d9ef">endp</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This procedure takes exactly two parameters and returns <code>BOOL</code> data, the first parameter is an address of an array to be filled with the return addresses, The second parameter is the number of addresses to read, it returns either TRUE on success or FALSE on failure, Now let&rsquo;s modify the C application we have written to trace its execution, We will add these lines at the top:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;DbgHelp.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment (lib, &#34;DbgHelp.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Number of addresses to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define ADDRESSES_LENGTH 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>EXTERN_C {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> BOOL <span style="color:#a6e22e">GrabRetAddresses</span>(LPVOID <span style="color:#f92672">*</span>pResult, DWORD dwSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>BOOL g_bSymInitialized <span style="color:#f92672">=</span> FALSE;
</span></span></code></pre></div><p>Then, we will modify the funcC, To calls our tracing function rather than <code>getchar</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcC</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcC&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">TraceCalls</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>TraceCalls</code> function is a C function that calls the assembly procedure and prints the addresses and their relative function names on the screen. It&rsquo;s a cool function and was implemented as following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">TraceCalls</span>() {
</span></span><span style="display:flex;"><span>	PCHAR cpName;
</span></span><span style="display:flex;"><span>	LPVOID lpAddresses[ADDRESSES_LENGTH] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">GrabRetAddresses</span>(lpAddresses, ADDRESSES_LENGTH) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Failed to grab ret addresses&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> nIdx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; nIdx <span style="color:#f92672">&lt;</span> ADDRESSES_LENGTH; nIdx<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Return Addr = %p, Function Name = &#34;</span>, lpAddresses[nIdx]);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( cpName <span style="color:#f92672">=</span> <span style="color:#a6e22e">FuncNameByAddr</span>(lpAddresses[nIdx]) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cpName);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">free</span>(cpName);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;UNKNOWN&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function calls another function as you see called <strong>FuncNameByAddr</strong> which is responsible for getting the function name by its address that we get it via the assembly function <strong>GrabRetAddresses</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>PCHAR <span style="color:#a6e22e">FuncNameByAddr</span>(LPVOID lpFuncAddr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	PSYMBOL_INFO pSymbol;
</span></span><span style="display:flex;"><span>	PCHAR cpName;
</span></span><span style="display:flex;"><span>	HANDLE hCurrProc <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetCurrentProcess</span>();
</span></span><span style="display:flex;"><span>	DWORD64 dw64Displacement <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	DWORD dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(SYMBOL_INFO) <span style="color:#f92672">+</span> MAX_SYM_NAME <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(TCHAR);
</span></span><span style="display:flex;"><span>	DWORD dwNameSize <span style="color:#f92672">=</span> MAX_SYM_NAME <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(TCHAR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> g_bSymInitialized )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">SymInitialize</span>(hCurrProc, NULL, TRUE) )
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		g_bSymInitialized <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> (pSymbol <span style="color:#f92672">=</span> (PSYMBOL_INFO) <span style="color:#a6e22e">malloc</span>(dwSize)) )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ZeroMemory</span>(pSymbol, dwSize);
</span></span><span style="display:flex;"><span>	pSymbol<span style="color:#f92672">-&gt;</span>SizeOfStruct <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(SYMBOL_INFO);
</span></span><span style="display:flex;"><span>	pSymbol<span style="color:#f92672">-&gt;</span>MaxNameLen <span style="color:#f92672">=</span> MAX_SYM_NAME;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">SymFromAddr</span>(hCurrProc, (DWORD64) lpFuncAddr, <span style="color:#f92672">&amp;</span>dw64Displacement, pSymbol) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free</span>( pSymbol );
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>(cpName <span style="color:#f92672">=</span> (PCHAR) <span style="color:#a6e22e">malloc</span>(dwNameSize)) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free</span>( pSymbol );
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">UnDecorateSymbolName</span>(pSymbol<span style="color:#f92672">-&gt;</span>Name, (PSTR) cpName, dwNameSize, UNDNAME_COMPLETE);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">free</span>( pSymbol );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> cpName;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function as we said grabs the function name via its address, It is not as complicated as you imagine, first, we use <strong>SymInitialize</strong> API to initialize the symbol handler for the process, then we allocate some memory for the <strong>Symbol</strong> with a specific size, then we fill this memory with zeros and put some data needed by the API, to avoid a crash or any problem when the API uses it, after that we call the <strong>SymFromAddr</strong> and pass the function address and the symbol by reference to be written by the API, the symbol contains valuable information one of them is the function name that we search for, then we allocate some memory for the function name and grab it, and finally we deallocate the symbol and return the name to the caller which will be responsible for deallocating it.</p>
<p>Let&rsquo;s run it:</p>
<center><img src="/imgs/stack_trace.png" width="512"/></center>
<p>As you see we could trace the chain of function calls depending on the valuable pieces of information that we grabbed from the stack, and we will abuse these things later in <strong>Malware Development</strong> series. We will exploit this things to bypass the most advanced security tools.</p>
<p>Also, we can grab this information remotely from another process via APIs like <strong>StackWalk</strong>, but I wanted to show you how that can happen exactly, so that&rsquo;s why I have developed our stack walker using assembly.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Try writing your own codes and playing with the debugger, and seeing what the stack looks like at each step, and how your code gets handled at the low level to solidify your understanding.
Please don&rsquo;t forget to share this article if you enjoyed it. Thank you for reading, goodbye.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
         | 
        <a href="https://www.linkedin.com/in/0xNinjaCyclone">Linkedin</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
