<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 2- Stack Memory | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 2- Stack Memory</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2023-12-13</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 1570 words</span>
  <span> • 8 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/stack">stack</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p>Hello everyone, I hope you are doing well. In this article, we will discuss the stack, how it works. and the operations performed on it. Understanding the stack will pave the way for us in the exploit development field and other fields like malware development.</p>
<h2 id="what-is-stack">What is Stack?</h2>
<p>The stack is a temporary memory that behaves as a first-in-last-out buffer, divided into a group of frames on top of each other. Each stack frame stores data such as parameters, local variables, and other temporaries things for a particular function. There are two very important elements that you should know, which are stack base pointer and stack pointer.</p>
<h2 id="what-is-the-stack-frame-how-it-works">What is the stack frame? How it works?</h2>
<p>When any function gets called, a new stack frame will be initialized above the caller&rsquo;s stack frame to store the function&rsquo;s data such as variables and parameters as we said before, and BP will be pushed onto the stack to remember later the caller&rsquo;s frame base address, and also the function&rsquo;s return address which tells the processer what is the next instruction to execute after current function completes its task, when the function completes its execution it has to return back to the caller, the new stack frame will be deleted and BP and return address will be popped off</p>
<h2 id="what-is-the-stack-base-pointer-bp-">What is the stack base pointer (BP) ?</h2>
<p>The stack base pointer is a register that refers to the bottom of the stack frame during function calls. Which normally refers to higher addresses as it grows towards lower.</p>
<h2 id="what-is-the-stack-pointer-sp-">What is the stack pointer (SP) ?</h2>
<p>The stack pointer is a register that refers to the top of the stack frame during function calls. Which normally refers to lower addresses, When the function finishes its task, the SP will refers to the current BP which the top of the caller&rsquo;s stack frame.</p>
<h2 id="how-software-deal-with-the-stack">How software deal with the stack?</h2>
<p>Let&rsquo;s write a simple C code and show you what the stack looks like and how the program handles the stack:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcX</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcX&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcY</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcY&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">funcX</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">funcY</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a simple program that has 3 functions the main function which is the entry point, funcX, funcY, both of them display a Hello message on the screen, when funcX gets called we expect that a new stack frame will be created above the main&rsquo;s stack frame and both the return address and BP are pushed onto the stack, so let&rsquo;s see what happens:</p>
<center><img src="/imgs/dbg_stack.png" width="512"/></center>
<p>As you see in the picture when the funcX was called, following things happened.</p>
<ul>
<li>1 - The function&rsquo;s return address is pushed onto the stack, to remember what the next instruction after calling funcX, to resume the main execution after funcX completes its execution</li>
<li>2 - The BP which describes the bottom of the main&rsquo;s stack frame is pushed onto the stack to remember it later when the function finishes, then BP jumps up to be at the SP position and SP will be automatically brought up and down when temporary data is pushed and popped, that&rsquo;s literally how a new stack frame gets initialized.</li>
<li>3 - When funcX finishes its execution, both BP and SP will be pointing at the bottom of the funcX&rsquo;s stack frame, which is the top of the main&rsquo;s stack frame, so the SP refers to the correct offset but BP not, that&rsquo;s why the BP was pushed onto the stack, so BP will be popped off to remember the bottom of the main&rsquo;s stack frame, after that the function&rsquo;s return address will be popped of automatically in IP register, To resume the execution of the main function.</li>
</ul>
<h2 id="illustration-showing-how-the-stack-works">Illustration showing how the stack works</h2>
<p>This illustration demonstrates how the stack behaves with the code we explained above:</p>
<center><img src="/imgs/stack.png" width="512"/></center>
<h2 id="advanced-benefits-of-return-address">Advanced benefits of return address</h2>
<p>Did you ask yourself before how tools such as process hacker can track the execution of the programs and know exactly the chain of calls, How do AV/EDRs analyze the programs during execution and detect either malicious or not?</p>
<p>The <strong>return address</strong> is the reason, these tools grab the return addresses via walking through the stack frames, Each stack frame has a base pointer of the previous stack frame as we said before, Which makes it like a linked list data structure.</p>
<p>Let&rsquo;s write a simple C code and show you what i mean.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcC</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcC&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcB</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcB&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcC</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcA</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcA&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcB</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from main&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcA</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you see four functions call each other as following, main-&gt;funcA-&gt;funcB-&gt;funcC, Let&rsquo;s see how process hacker can track this flow.</p>
<center><img src="/imgs/ph_stack.png" width="512"/></center>
<p>Let&rsquo;s try to do it ourselves. First we need to develop our assembly function that retrieves return addresses from the stack frames.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Author =&gt; Abdallah Mohamed ( 0xNinjaCyclone )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.386</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.MODEL</span> <span style="color:#66d9ef">flat</span>, <span style="color:#66d9ef">c</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.code</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">GrabRetAddresses</span> <span style="color:#66d9ef">proc</span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">edx</span>, [<span style="color:#66d9ef">esp</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">4</span>]       <span style="color:#75715e">; Where the results will be stored
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, [<span style="color:#66d9ef">esp</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">8</span>]       <span style="color:#75715e">; Number of addresses to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>             <span style="color:#75715e">; bSuccess = FALSE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">ebp</span>             <span style="color:#75715e">; BP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	grab:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dec</span> <span style="color:#66d9ef">ecx</span>                  <span style="color:#75715e">; dwSize--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">esi</span>, [<span style="color:#66d9ef">ebx</span>]           <span style="color:#75715e">; Previous BP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edi</span>, [<span style="color:#66d9ef">ebx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">4</span>]       <span style="color:#75715e">; Return Address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">esi</span>            <span style="color:#75715e">; We have to stop if we reach the stack base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">jz</span> <span style="color:#66d9ef">finish</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">edx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">ecx</span> * <span style="color:#ae81ff">4</span>], <span style="color:#66d9ef">edi</span> <span style="color:#75715e">; pResult[dwSize] = pRetAddr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">esi</span>             <span style="color:#75715e">; Bring down to the next stack frame
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>            <span style="color:#75715e">; Stop if we completed our task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">grab</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">eax</span>                  <span style="color:#75715e">; bSuccess = TRUE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	finish:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span>                      <span style="color:#75715e">; return to the caller
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">GrabRetAddresses</span> <span style="color:#66d9ef">endp</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This procedure takes exactly two parameters and returns <code>BOOL</code> data, the first parameter is an address of an array to be filled with the return addresses, The second parameter is the number of addresses to read, it returns either TRUE on success or FALSE on failure, Now let&rsquo;s modify the C application we have written to trace its execution, We will add these lines at the top:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;DbgHelp.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment (lib, &#34;DbgHelp.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Number of addresses to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define ADDRESSES_LENGTH 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>EXTERN_C {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> BOOL <span style="color:#a6e22e">GrabRetAddresses</span>(LPVOID <span style="color:#f92672">*</span>pResult, DWORD dwSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>BOOL g_bSymInitialized <span style="color:#f92672">=</span> FALSE;
</span></span></code></pre></div><p>Then, we will modify the funcC, To calls our tracing function rather than <code>getchar</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">funcC</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello from funcC&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">TraceCalls</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>TraceCalls</code> function is a C function that calls the assembly procedure and prints the addresses and their relative function names on the screen. It&rsquo;s a cool function and was implemented as following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">TraceCalls</span>() {
</span></span><span style="display:flex;"><span>	PCHAR cpName;
</span></span><span style="display:flex;"><span>	LPVOID lpAddresses[ADDRESSES_LENGTH] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">GrabRetAddresses</span>(lpAddresses, ADDRESSES_LENGTH) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Failed to grab ret addresses&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> nIdx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; nIdx <span style="color:#f92672">&lt;</span> ADDRESSES_LENGTH; nIdx<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Return Addr = %p, Function Name = &#34;</span>, lpAddresses[nIdx]);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( cpName <span style="color:#f92672">=</span> <span style="color:#a6e22e">FuncNameByAddr</span>(lpAddresses[nIdx]) )
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cpName);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">free</span>(cpName);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;UNKNOWN&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function calls another function as you see called <strong>FuncNameByAddr</strong> which is responsible for getting the function name by its address that we get it via the assembly function <strong>GrabRetAddresses</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>PCHAR <span style="color:#a6e22e">FuncNameByAddr</span>(LPVOID lpFuncAddr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	PSYMBOL_INFO pSymbol;
</span></span><span style="display:flex;"><span>	PCHAR cpName;
</span></span><span style="display:flex;"><span>	HANDLE hCurrProc <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetCurrentProcess</span>();
</span></span><span style="display:flex;"><span>	DWORD64 dw64Displacement <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	DWORD dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(SYMBOL_INFO) <span style="color:#f92672">+</span> MAX_SYM_NAME <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(TCHAR);
</span></span><span style="display:flex;"><span>	DWORD dwNameSize <span style="color:#f92672">=</span> MAX_SYM_NAME <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(TCHAR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> g_bSymInitialized )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">SymInitialize</span>(hCurrProc, NULL, TRUE) )
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		g_bSymInitialized <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> (pSymbol <span style="color:#f92672">=</span> (PSYMBOL_INFO) <span style="color:#a6e22e">malloc</span>(dwSize)) )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ZeroMemory</span>(pSymbol, dwSize);
</span></span><span style="display:flex;"><span>	pSymbol<span style="color:#f92672">-&gt;</span>SizeOfStruct <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(SYMBOL_INFO);
</span></span><span style="display:flex;"><span>	pSymbol<span style="color:#f92672">-&gt;</span>MaxNameLen <span style="color:#f92672">=</span> MAX_SYM_NAME;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> <span style="color:#a6e22e">SymFromAddr</span>(hCurrProc, (DWORD64) lpFuncAddr, <span style="color:#f92672">&amp;</span>dw64Displacement, pSymbol) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free</span>( pSymbol );
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>(cpName <span style="color:#f92672">=</span> (PCHAR) <span style="color:#a6e22e">malloc</span>(dwNameSize)) )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free</span>( pSymbol );
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">UnDecorateSymbolName</span>(pSymbol<span style="color:#f92672">-&gt;</span>Name, (PSTR) cpName, dwNameSize, UNDNAME_COMPLETE);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">free</span>( pSymbol );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> cpName;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function as we said grabs the function name via its address, It is not as complicated as you imagine, first, we use <strong>SymInitialize</strong> API to initialize the symbol handler for the process, then we allocate some memory for the <strong>Symbol</strong> with a specific size, then we fill this memory with zeros, to avoid a crash or any problem when the API uses it, after that we call the <strong>SymFromAddr</strong> and pass the function address and the symbol by reference to be written by the API, the symbol contains valuable information one of them is the function name that we search for, then we allocate some memory for the function name and grab it, and finally we deallocate the symbol and return the name to the caller which will be responsible for deallocating it.</p>
<p>Let&rsquo;s run it:</p>
<center><img src="/imgs/stack_trace.png" width="512"/></center>
<p>As you see we could trace the chain of function calls depending on the valuable pieces of information that we grabbed from the stack, and we will abuse these things later in <strong>Malware Development</strong> series. We will exploit this things to bypass the most advanced security tools.</p>
<p>Also, we can grab this information remotely from another process via APIs like <strong>StackWalk</strong>, but I wanted to show you how that can happen exactly, so that&rsquo;s why I have developed our stack walker using assembly.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Try writing your own codes and playing with the debugger, and seeing what the stack looks like at each step, and how your code gets handled at the low level to solidify your understanding.
Please don&rsquo;t forget to share this article if you enjoyed it. Thank you for reading, goodbye.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
